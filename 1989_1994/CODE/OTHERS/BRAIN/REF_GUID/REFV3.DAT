T:ST 68k Reference Version 3, ½ 1990-1991 Neil Smith.

This is version 3 of my program, 'ST 68k Reference', distributed by
Budgie UK, The fairer face of PD.

Neil Smith: 42 Hayes Road,Budgie UK: 5 Minster Close,
Bromley,%Rayleigh,
Kent,(Essex,
BR2 9AA.%SS6 8SF.

This version has been a total rewrite in Lattice C version 5.04.00.

This program should be smaller and faster than previous versions and
yet have more features and greater information content. It is very easy
to use. Just double-click on underlined items to get more information.

  ;
L:About Version 3:2;
;
L:Copyrights:3;
;
L:Index:4;
;
L:Bibliography:169
}
T:About Version 3
Version 3 of the ST 68k Reference program is a complete rewrite. The only
similarity between this versions 2 and 3 is the name.

1. It is no longer a desk accessory. If this is a problem, (i.e. your
program development system does not have a 'Run Other...' option),
please get in touch.

2. The method of accessing the information is much simplified. All that is
required is a double-click on the word that you want more information on.
A click in the close box takes you to the previous page you were
accessing, (maximum 20 page memory). Clicking the full box quits.

3. The space taken in the data file for a single page of information has
been drastically reduced. The file is bigger because there are more pages!
}
T:Copyrights.
This program and all associated documents are the copyright of Neil Smith.

And Distributed with permission by Budgie UK, The fairer face of PD.

The author accepts absolutely no responsibility for any events resulting
from the use or abuse of this program. While he has attempted to ensure
that the information within this system is correct he cannot be sure that
errors do not exist.
}
T:Index
Double-click on your
area of interest.

Operating System:
1. ;
L:Bios:5;
2. ;
L:Xbios:6
3. ;
L:Gemdos:7;
 4. ;
L:AES:8
5. ;
L:VDI:9;
6. ;
L:Line-A:10

Chips:
7. ;
L:MC68000:11;
 8. ;
L:MC68901:12
9. ;
L:MC6850:13;
  10.;
L:YM2149:14

11.;
L:System Variables:15
12.;
L:Configuration Registers:16
13.;
L:VT52 Codes:17
14.;
L:ASCII Codes:18
15.;
L:Keyboard Codes:19
16.;
L:System Error Codes:20
17.;
L:Exception Vectors:472
}
T:The Bios
Within this section each of the Bios function is described. Each
description will show the arguments that have to be placed on the
stack in the order that they are placed. Return values are detailed
along with stack tidying requirements.

The Bios is accessed through;
L:TRAP:454;
vector number 13. The registers
D0-D2 and A0-A2 may be changed during a Bios call, and should be
saved by a users program if their contents  will be required later.

 ;
L:Getbpb:21;
;
L:Getmpb:22
 ;
L:Bconstat:23;
  ;
L:Bcostat:24;
  ;
L:Bconin:25;
  ;
L:Bconout:26
 ;
L:Rwabs:27
 ;
L:Setexc:28
 ;
L:Tickcal:29
 ;
L:Mediach:30
 ;
L:Drvmap:31
 ;
L:Kbshift:32
}
T:Getbpb - Get Bios Parameter Block
This function returns a pointer to the Bios parameter block
of the specified drive in register D0.L, or 0 on error.

  move.wdev,-(sp)Device: A=0 B=1 C=2 etc.
  move.w#$7,-(sp)Function number $7
  trap#13Bios trap number
  addq.l#4,spTidy the stack

The Bios parameter block has the following format

  $0recsizsector size in bytes
  $2clsizcluster size in sectors
  $4clsizbcluster size in bytes
  $6rdlendirectory length in sectors
  $8fsizfat size in sectors
  $Afatrecsector of the second fat
  $Cdatrecsector of the first data cluster
  $Enumclnumber of data cluster on disk
  $10bflagsmiscellaneous flags
}
T:Getmpb - Get Memory Parameter Block
This function is called during the Gemdos startup sequence
and is not required subsequently. However here are the
details anyway. The function fills a 12 byte block pointed
to by its first argument with the memory parameter block.

  move.lpointer,-(sp)Pointer to 12-byte block
  clr.w-(sp)Function number $0
  trap#13Bios trap number
  addq.l#6,spTidy the stack

The MPB has this format

  $0md_mflPointer to memory free list
  $4md_malPointer to memory allocated list
  $8md_roverRoving pointer

There is no return value.
}
T:Bconstat - Return Input Device Status
This function returns the status of an input device in D0.L

  move.wdev,-(sp)Device to check
  move.w#$1,-(sp)Function number $1
  trap#13Bios trap number
  addq.l#4,spTidy the stack

Legal devices for this call are

  0PRT:The Centronics port
  1AUX:The RS-232 port
  2CON:The keyboard
  3MIDIThe MIDI interface

The return value is 0 if there are no characters available, or
-1 if there are characters available to be read.
}
T:Bcostat - Return Output Device Status
This function returns the status of an output device in D0.L

  move.wdev,-(sp)Device to check
  move.w#$8,-(sp)Function number $8
  trap#13Bios trap number
  addq.l#4,spTidy the stack

Legal devices for this call are

  0PRT:The Centronics port
  1AUX:The RS-232 port
  2CON:Console Device
  3MIDIThe MIDI interface
  4IKBDKeyboard port
  5+Raw screen device

The return value is 0 if the device is not ready to receive
or non-zero if the device is ready.
}
T:Bconin - Read A Character From A Device
This function reads a character from the specified device.

  move.wdev,-(sp)Device to read from
  move.w#$2,-(sp)Function number $2
  trap#13Bios trap number
  addq.l#4,spTidy the stack

Legal devices for this call are

  0PRT:The Centronics port
  1AUX:The RS-232 port
  2CON:Console Device
  3MIDIThe MIDI interface

The character read is placed in D0.L. If device 2 was being
read then the keyboard;
L:scan code:19;
will be placed in the lower
byte of the upper word. If bit 3 in the system variable
conterm is set then the shift key status is returned in the
upper byte of the upper word, see;
L:Kbshift.:32
}
T:Bconout - Write A Character To A Device
This function outputs a single character to the specified device.

  move.wc,-(sp)Character to write
  move.wdev,-(sp)Device to write to
  move.w#$3,-(sp)Function number $3
  trap#13Bios trap number
  addq.l#6,spTidy the stack

Legal devices for this call are the same as those for;
L:Bcostat.:24
When writing to the RS-232, MIDI or IKBD devices a return value
of 0 is used to indicate failure.
}
T:Rwabs - Read/Write Logical Sectors On A Device
This function is used to read and write logical sectors to and from
a device.

  move.wdev,-(sp)Device A=0 B=1 C=2 etc.
  move.wrecno,-(sp)First sector to read/write from
  move.wnumber,-(sp)How many sectors to read/write
  move.lbuffer,-(sp)Pointer to the buffer to use
  move.wrwflag,-(sp)Mode of operation
  move.w#$4,-(sp)Function number $4
  trap#13Biod trap number
  add.l#14,spTidy the stack

Any error state will be returned in D0.L, zero indicates success.
The buffer must be at least number * logical sector size bytes in
size and should be word aligned for efficiency. Rwflag is a bitmap

  0Write if set, Read if clear
  1Ignore media change status if set
  2Disable retry if set
  3Do not teranslate logical sectors to physical sector if set
}
T:Setexc - Set Exception Vectors
This function allows you to change or examine one of the 68000
L:exception vectors.:472;
The function returns the old value of a vector
in D0.L

  move.lroutine,-(sp)New exception routine
  move.wvector,-(sp)Number of vector to change
  move.w#$5,-(sp)Function number $5
  trap#13Bios trap number
  addq.l#8,spTidy the stack

Vectors that you can change are

  0-0xFFStandard 6000 exception vectors
  0x100System timer vector, etv_timer
  0x101Critical error handler, etv_critic
  0x102Process terminate handler, etv_term
  0x103-0x107Reserved

If you pass -1.L as your routine address then the vector will be
unchanged and its current address simply returned
}
T:Tickcal - Get System Timer Tick Time
This function simply returns the number of milliseconds between
two system timer calls. For current systems the value is 50.

  move.w#$6,-(sp)Function number $6
  trap#13Bios trap number
  addq.l#2,spTidy the stack
}
T:Mediach - Inquire Media Change
This function determines whether the media for a particular
device has been changed or not. The return state is passed
in D0.L

  move.wdev,-(sp)Device to check A=0 B=1 etc.
  move.w#$9,-(sp)Function number $9
  trap#13Bios trap number
  addq.l#4,spTidy the stack

The return value has the following meaning

  0Media has definitely not changed
  1Media may have changed
  2Media definitiely has changed
}
T:Drvmap - Inquire Which Drives Are Available
This function returns in D0.L a bitmap indicating which
drives are available.

  move.w#$A,-(sp)Function number $A
  trap#13Bios trap number
  addq.l#2,spTidy the stack

Each bit in the returned bitmap corresponds to a single device.
If the bit is set then the device is available. Drive A
corresponds to bit 0, B to bit 1 etc. On a single floppy system
bits 0 and 1 will always be set.

It is up to the device driver to adjust;
L:_drvbits:470;
if it wants
to be recognised.
}
T:Kbshift - Inquire Or Change The Keyboard Status
This function allows you to change or read the state of the keyboard's
shift keys. The old state of the keys is returned in D0.L

  move.wmode,-(sp)Mode to use
  move.w#$B,-(sp)Function number $B
  trap#13Bios trap number
  addq.l#4,spTidy the stack

Mode is a bitmap with a set bit indicating that a particular
key is down. The bits correspond to keys as shown below

  0Right shift key
  1Left shift key
  2Control key
  3Alternate key
  4Caps Lock key
  5Clr/Home key
  6Insert key

If mode is -1 then the state is simply read and not changed.
}
T:The eXtended Bios
Within this section each of the Xbios function is described. Each
description will show the arguments that have to be placed on the
stack in the order that they are placed. Return values are detailed
along with stack tidying requirements.

The Xbios is accessed through TRAP vector number 14. The registers
D0-D2 and A0-A2 may be changed during a Xbios call, and should be
saved by a users program if their contents  will be required later.

 ;
L:Bioskeys:33;
 ;
L:Blitmode:34;
;
L:Cursconf:35;
  ;
L:Dosound:36
 ;
L:Flopfmt:37;
  ;
L:Floprate:38;
;
L:Floprd:39;
;
L:Flopver:40
 ;
L:Flopwr:41;
;
L:Getrez:42;
  ;
L:Gettime:43;
;
L:Settime:44
 ;
L:Giaccess:45;
 ;
L:Ikbdws:46;
  ;
L:Initmous:47;
  ;
L:Iorec:48
 ;
L:Jenabint:49;
 ;
L:Jdisint:50;
 ;
L:Kbdvbase:51;
  ;
L:Kbrate:52
 ;
L:Keytbl:53;
;
L:Logbase:54;
 ;
L:Mfpint:55;
;
L:Midiws:56
 ;
L:Ongibit:57;
  ;
L:Offgibit:58;
;
L:Physbase:59;
  ;
L:Protobt:60
 ;
L:Prtblk:61;
;
L:Puntaes:62;
 ;
L:Random:63;
;
L:Rsconf:64
 ;
L:Scrdmp:65;
;
L:Setcolor:66;
;
L:Setpallete:67;
;
L:Setprt:68
 ;
L:Setscreen:69;
;
L:Ssbrk:70;
;
L:Supexec:71;
;
L:Vsync:72
 ;
L:Xbtimer:73
}
T:Bioskeys - Restore Keyboard Translation Tables
This function is used to restore the keyboard translation
tables to their power-up state. This call will usually only
be required if you have used the;
L:Keytbl:53;
function.

  move.w#$18,-(sp)Function number $18
  trap#14Xbios trap number
  addq.l#2,spTidy the stack
}
T:Blitmode - Get Or Set The BLiTTER Configuration
This function allows you to determine whether a BLiTTER is
available in the machine and then turn it on or off.

  move.wmode,-(sp)Action to perform
  move.w#$40,-(sp)Function number $40
  trap#14Xbios trap number
  addq.l#4,spTidy the stack

The following values for mode have the effects as shown

  0Perform blits in software
  1Perform blits in hardware
  -1Return current BLiTTER status

Bit 1 of the returned status will be set if there is a BLiTTER
available.
}
T:Cursconf - Configure The VT52 Cursor
This function allows you to change the way in which the
L:VT52:17;
cursor behaves.

  move.wrate,-(sp)Rate of blinking
  move.wfunction,-(sp)  Action to perform
  move.w#$19,-(sp)Function number $19
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

The function parameter can have one of the following meanings

  0Hide cursor
  1Show cursor
  2Disable blinking
  3Enable blinking
  4Set blink rate to 'rate'
  5Return current blink rate

The blink rate is specified in terms of the screen rate, 70Hz
for monochrome and 50/60Hz for colour.
}
T:Dosound - Initialise The Sound Daemon
This function sets the sound daemon running through a sequence
of instructions.

  move.lpointer,-(sp)Pointer to sound commands
  move.w#$20,-(sp)Function number $20
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

The pointer parameter points to the list of instructions to be
executed. These take the following format.

Values from 0-15 specify a;
L:sound register:14;
into which the following
byte is loaded.
Value $80 is followed by a byte which is loaded in to a temporary
register.
Value $81 is followed by three bytes. The first is the register to
load with the value from the temporary register. The second is a 2's
complement number to add to the temporary register until it is equal
to the third.
Values $82-$ff are followed by the number of timer ticks to wait for
until the next sound is executed, or 0 to halt.
}
T:Flopfmt - Format A Track On A Floppy Disk
This function will format a single track on a floppy disk.

  move.wvirgin,-(sp)Value to place on disk, (usually $e5e5)
  move.lmagic,-(sp)Should be $87654321 to format
  move.wintrlv,-(sp)Specified the interleave to use
  move.wside,-(sp)Specifies the side to format
  move.wtrack,-(sp)Specifies the track to format
  move.wspt,-(sp)Number of sectors per track
  move.wdev,-(sp)Device to format, A=0, B=1
  move.lskew,-(sp)Pointer to word array indicating order of
.sectors on disk, (only if intrlv = -1)
  move.lbuf,-(sp)Pointer to an 8Kbyte buffer
  move.w#$A,-(sp)Function number $A
  trap#14Xbios trap number
  add.l#26,spTidy the stack

If any sectors failed to format then they are listed in 'buf' on
return.
}
T:Floprate - Set Floppy Disk Step Rate
This function, (TOS 1.4 and above only), allows you to set the
step rate for the floppy disks.

  move.wrate,-(sp)0=6ms 1=12ms 2=2ms 3=3ms
  move.wdev,-(sp)A=0 B=non-zero
  move.w#$29,-(sp)Function number $29, (I think!)
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

The old seek rate for the specified device is returned. To simply
get the return value specify -1 as the rate.

On versions of the operating system before 1.4 the system variable
L:seekrate:172;
should be used.
}
T:Floprd - Read Sectors From A Floppy Disk
This function allows you to read a number of sectors from a specified
floppy disk.

  move.wcount,-(sp)Number of sectors
  move.wside,-(sp)Side to read from
  move.wtrack,-(sp)Track to read from
  move.wsector,-(sp)Number of the first sector to read
  move.wdev,-(sp)Device to use, A=0, B=1
  clr.l-(sp)
  move.lbuffer,-(sp)Buffer for incoming data, 512*count
  move.w#$8,-(sp)Function number $8
  trap#14Xbios trap number
  add.l#20,spTidy the stack

The return value is 0 if the specified number of sectors were read
correctly, or a;
L:negative error:20;
number if not.

L:Flopwr:41;
is the compliment to this function, writing sectors to a disk.
}
T:Flopver - Verify Sectors On A Floppy Disk
This function allows you to verify a number of sectors on a specified
floppy disk.

  move.wcount,-(sp)Number of sectors
  move.wside,-(sp)Side to verify
  move.wtrack,-(sp)Track to verify
  move.wsector,-(sp)Number of the first sector to verify
  move.wdev,-(sp)Device to use, A=0, B=1
  clr.l-(sp)
  move.lbuffer,-(sp)Buffer for list of falied sectors, 1Kbyte
  move.w#$13,-(sp)Function number $13
  trap#14Xbios trap number
  add.l#20,spTidy the stack

The return value is 0 if all sectors verified correctly or a;
L:negative:20
L:error:20;
number if not.
}
T:Flopwr - Write Sectors To A Floppy Disk
This function allows you to write a number of sectors to a specified
floppy disk.

  move.wcount,-(sp)Number of sectors
  move.wside,-(sp)Side to write to
  move.wtrack,-(sp)Track to write to
  move.wsector,-(sp)Number of the first sector to write
  move.wdev,-(sp)Device to use, A=0, B=1
  clr.l-(sp)
  move.lbuffer,-(sp)Buffer for outgoing data, 512*count
  move.w#$9,-(sp)Function number $9
  trap#14Xbios trap number
  add.l#20,spTidy the stack

The return value is 0 if the specified number of sectors were written
correctly, or a;
L:negative error:20;
number if not.

L:Floprd:39;
is the compliment to this function, reading sectors from a disk.
}
T:Getrez - Find Current Screen Mode
This function will return a value dependent upon the current screen
mode.

  move.w#$4,-(sp)Function number $4
  trap#14Xbios trap number
  addq.l#2,spTidy the stack

The returned value has the following meaning

  0Low resolution320 * 200 * 16
  1Medium resolution  640 * 200 * 4
  2High resolution640 * 400 * 2

If you use this function you are practically guaranteed that your
programs will not work correctly in any of the new screen modes.
}
T:Gettime - Get IKBD Time
This function returns the date and time currently stored in the
IKBD clock.

  move.w#$17,-(sp)Function number $17
  trap#14Xbios trap number
  addq.l#2,spTidy the stack

The date and time are returned in D0.L in the following format

Bits
0-4Second in two second increments, 0-29
5-10Minute, 0-59
11-15Hour, 0-23
16-20Day, 0-31
21-24Month, 1-12
25-31Year minus 1980, 0-127
 
The function used to set the IKBD time is;
L:Settime.:44
}
T:Settime - Set IKBD Time
This function sets the date and time stored in the IKBD clock.

  move.ltime,-(sp)Date and Time
  move.w#$16,-(sp)Function number $16
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

The 'time' parameter is packed in exactly the same way as for
L:Gettime.:43
}
T:Giaccess - Access Sound Chip Registers
This function is used to access the;
L:YM2149 sound chip:14;
registers.

  move.wregister,-(sp)  Number of the register to access
  move.wdata,-(sp)Value to write in to register
  move.w#$1C,-(sp)Function number $1C
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

The 'register' parameter should be a number between 0 and 15
specifying the register to use. If bit 7 of this parameter is
set then the register will not be changed, the old value merely
returned.

The new value of the register is returned.
}
T:Ikbdws - Write A String To The Intelligent Keyboard
This function is used to send a string of commands to the
intelligent keyboard processor.

  move.lpointer,-(sp)Pointer to the list of commands
  move.wnumber,-(sp)Number of bytes to send - 1
  move.w#$19,-(sp)Function number $19
  trap#14Xbios trap number
  addq.l#8,spTidy the stack
}
T:Initmous - Set The Mouse Mode
This function enables you to change the way in which the mouse
is to operate. A number of modes are available.

  move.lvector,-(sp)Address of packet handler
  move.lparam,-(sp)Pointer to a parameter block
  move.wmode,-(sp)Mode in which the mouse is to operate
  clr.w-(sp)Function number $0
  trap#14Xbios trap number
  add.l#12,spTidy the stack

The modes available are

  0Disable mouse
  1Relative mouse mode
  2Absolute mouse mode
  4Keycode mode
}
T:Iorec - Find Serial Device Input/Ouput Record
This function returns the address of the buffer data record for
the specified input device.

  move.wdev,-(sp)Device 0=RS232 1=Keyboard 2=MIDI
  move.w#$E,-(sp)Function number $E
  trap#14Xbios trap number
  addq.l#4,spTidy the stack

The returned address points to a record formed as shown

  $0ibufAddress of input buffer
  $4ibufsizSize of input buffer
  $6ibufhdHead index
  $8ibuftlTail index
  $AibuflowLow water mark
  $CibufhiHigh water mark

If the device requested was the RS232 port then the output record
immediately folows the input record.
}
T:Jenabint - Enable An Interrupt On The MFP
This function is used to enable a specific interrupt on the;
L:MFP.:12

  move.wnumber,-(sp)Interrupt number
  move.w#$1A,-(sp)Function number $1A
  trap#14Xbios trap number
  addq.l#4,spTidy the stack

L:Jdisint:50;
is the complementary function to disable an interrupt.
L:Mfpint:55;
is used to change interrupt handlers.
}
T:Jdisint - Disable An Interrupt On The MFP
This function is used to disable a specific interrupt on the;
L:MFP.:12

  move.wnumber,-(sp)Interrupt number
  move.w#$1B,-(sp)Function number $1B
  trap#14Xbios trap number
  addq.l#4,spTidy the stack

L:Jenabint:49;
is the complementary function to enable an interrupt.
L:Mfpint:55;
is used to change interrupt handlers.
}
T:Kbdvbase - Return Keyboard Vector Table
This function returns the address of a table that contains pointers
to routines which process the data from the keyboard processor.

  move.w#$22,-(sp)Function number $22
  trap#14Xbiod function number
  addq.l#2,spTidy the stack

The format of the returned table is as shown

  $0midivecMIDI input
  $4vkbderrKeyboard error
  $8vmdierrMIDI error
  $CstatvecIKBD status
  $10mousevecMouse routines
  $14clockvecClock time routines
  $18joyvecJoystick routines
  $1CmidisysMIDI system vector
  $20ikbdsysIKBD system vector
}
T:Kbrate - Get Or Set The Keyboard Repeat Rate And Delay
This function allows you to change the time between a key press
and it repeating, and the time between those repeats.

  move.wrate,-(sp)50Hz system ticks between repeats
  move.wdelay,-(sp)50Hz system ticks before repeating
  move.w#$23,-(sp)Function number $23
  trap#14Xbios function number
  addq.l#6,spTidy the stack

The function returns a packed word with the low order byte
containing the previous repeat value and the high order byte
the previous delay.

If either parameter is -1 then the value is not changed.
}
T:Keytbl - Change The Keyboard Translation Tables
This function is used to change the layout of the keyboard.

  move.lcapslock,-(sp)  Address of caps lock translation table
  move.lshift,-(sp)Address of shift translation table
  move.lunshift,-(sp)Address of unshift translation table
  move.w#$10,-(sp)Function number $10
  trap#14Xbios trap number
  add.l#14,spTidy the stack

If any of the tables is to remain unchanged then pass -1 as its
address.

The function returns the address of a table that contains the addresses
of each of the translation tables.

  $0Normal table
  $4Shifted table
  $8Caps-lock table

Use;
L:Bioskeys:33;
to return the tables to normal.
}
T:Logbase - Return Address Of Logical Screen
This function returns the address of the current logical screen.
That is the screen to which all VDI drawing operations are applied.

  move.w#$3,-(sp)Function number $3
  trap#14Xbios trap number
  addq.l#2,spTidy the stack

Physbase returns the address of the physical screen.
}
T:Mfpint - Set MFP Interrupt Handler
This function is used to change one of the;
L:MFP:12;
interrupt vectors.

  move.lvector,-(sp)Addres of new routine
  move.wnumber,-(sp)Number of interrupt to change
  move.w#$D,-(sp)Function number $D
  trap#14Xbios trap number
  addq.l#8,spTidy the stack

The interrupt numbers can be found under the section dealing with
the;
L:MFP.:12

There is no way to determine an MFP interrupt value. Thus once it
has been changed there is no way to return it.

L:Jenabint:49;
and;
L:Jdisint:50;
are used to enable and disable MFP interrupts.
Installing an interrupt does not ensure that it is enabled.
}
T:Midiws - Write A String To The MIDI port.
This function is used to send a string of commands to the
MIDI port.

  move.lpointer,-(sp)Pointer to the list of commands
  move.wnumber,-(sp)Number of bytes to send - 1
  move.w#$C,-(sp)Function number $C
  trap#14Xbios trap number
  addq.l#8,spTidy the stack
}
T:Ongibit - Atomically Set Port A Bit
This function is used to atomically set a bit in port A of the
YM2149 sound chip.

  move.wbit,-(sp)Bit to set, 0-7
  move.w#1E,-(sp)Function number $1E
  trap#14Xbios trap number
  addq.l#4,spTidy the stack

The purposes of these bits are as shown

  0Floppy side select
  1Drive A select
  2Drive B select
  3RS-232 RTS
  4RS-232 DTR
  5Centronics strobe
  6General Purpose Output
  7Unused

The complement of this function to clear bits is Offgibit.
}
T:Offgibit - Atomically Clear Port A Bit
This function is used to atomically clear a bit in port A of the
YM2149 sound chip.

  move.wbit,-(sp)Bit to clear, 0-7
  move.w#1D,-(sp)Function number $1D
  trap#14Xbios trap number
  addq.l#4,spTidy the stack

The purposes of these bits can be seen under Ongibit.

The complement of this function to set bits is Ongibit.
}
T:Physbase - Return Address Of Physical Screen
This function returns the address of the current physical screen.
That is the screen which is currently displayed.

  move.w#$2,-(sp)Function number $2
  trap#14Xbios trap number
  addq.l#2,spTidy the stack

Logbase returns the address of the logical screen.
}
T:Protobt - Buid A Prototype Boot Sector
This function is used to build a boot sector for a floppy
disk.

  move.wexec,-(sp)0=non-exec 1=executable -1=unchanged
  move.wtype,-(sp)The type of the disk
  move.lserialno,-(sp)  The serial number to use
  move.lbuffer,-(sp)Address of 512 byte buffer to use
  move.w#$12,-(sp)Function number $12
  trap#14Xbios trap number
  add.l#14,spTidy the stack

the disk types are

  040 track, single sided
  140 track, double sided
  280 track, single sided
  380 track, double sided
  -1Keep current type information

If 'serialno' >= $1000000 a random number is generated and used
}
T:Prtblk - Output A Block To The Printer
This function can be used to output a bitmap to the printer.

  move.lpointer,-(sp)Address of parameter list
  move.w#$24,-(sp)Function number $24
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

The parameter list has the following format

  $0blkptrAddress of block to print
  $4offsetBit offset from start of block
  $6widthBitmap pixel width
  $8heightBitmap height
  $AleftBits to skip at left edge
  $CrightBits to skip at right edge
  $EsrcresSource resolution, from Getrez
  $10dstresDestination resolution
  $12colpalAddress of the colour palette
  $16  ;
L:type:173;
Printer type
  $18portPort
  $1AmasksAddress of table of masks to use
}
T:Prtblk Parameter List cont.
'type' can have values

  0  Monochrome Atari
  1  Colour Atari
  2  Monochrome Daisy Wheel
  3  Monochrome Epson Compatible

'dstres' can have values

  0  Draft
  1  Final

'port' can have values

  0  Parallel
  1  Serial
}
T:Puntaes - Discard AES
This function is used to remove the AES and free any memory
it occupies. This will only work on RAM-loaded TOS.

  move.w#$27,-(sp)Function number $27
  trap#14Xbios trap number
  addq.l#2,spTidy the stack
}
T:Random - Generate Random Number
This function returns a 24 bit random number.

  move.w#$11,-(sp)Function number $11
  trap#14Xbios trap number
  addq.l#2,spTidy the stack

The distibution for bit 0 is exactly 50/50 so use with care.
}
T:Rsconf - Configure RS-232 Port
This function can be used to configure the RS-232 serial
communication port.

  move.wscr,-(sp)Synchronous char. register
  move.wtsr,-(sp)Transmit status register
  move.wrsr,-(sp)Receive status register
  move.wucr,-(sp)USART control register
  move.wctrl,-(sp)Flow control mode
  move.wbaud,-(sp)Baud rate to use
  move.w#$F,-(sp)Function number $F
  trap#14Xbios trap number
  add.l#14,spTidy the stack

The values for the baud rates areAnd flow control
  0  192004  2400860012  1340  None
  1  96005  2000930013  1101  XON/XOFF
  2  48006  180010  20014  752  RTS/CTS
  3  36007  120011  15015  503  ON/OFF & RTS/CTS
}
T:Scrdmp - Copy Screen To Printer
This function generates a screen dump in exactly the same way
as the Alt-Help key combination.

  move.w#$14,-(sp)Function number $14
  trap#14Xbios trap number
  addq.l#2,spTidy the stack
}
T:Setcolor - Set Colour Palette
This function is used to set a specified logical colour.

  move.wcolour,-(sp)RGB
  move.wcolornum,-(sp)  Logical colour to set
  move.w#$7,-(sp)Function number $7
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

The RGB parameter takes the following form

  Bits
  0-3Blue} In each of these the highest order bit of the 4
  4-7Green} is the lowest order bit in the colour. This is to
  8-11  Red} retain backward compatibility from the STe to the ST
  12-15 Unused

If a colour is not to be changed then a value of -1 should be passed.

The function returns the value of the old logical colour.
}
T:Setpallete - Set Display Palette
This function is used to install a new colour palette.

  move.lpointer,-(sp)Pointer to array of 16 words
  move.w#$6,-(sp)Function number $6
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

Each colour in the word array takes the same format as in Setcolor.
The palette is installed at the next vertical blank.
}
T:Setprt - Set Or Get The Printer Configuration
This function is used to set or get the current printer configuration.

  move.wconfig,-(sp)Configuration to use
  move.w#$21,-(sp)Function number $21
  trap#14Xbios trap number
  addq.l#4,spTidy the stack

The 'config' parameter is a bitmap with the following meaning

Bit clear(0)Bit set(1)

  0Dot matrixDaisy wheel
  1MonochromeColour
  2Atari modeEpson compatible
  3Draft modeFinal mode
  4Parallel portSerial port
  5ContinuousSingle sheet
}
T:Setscreen - Set The Screen Parameters
This function is used to change the current screen parameters.

  move.wres,-(sp)New resolution, as Getrez
  move.lphysaddr,-(sp)  Address of physical screen
  move.llogaddr,-(sp)Address of logical screen
  move.w#$5,-(sp)Function number $5
  trap#14Xbios trap number
  add.l#12,spTidy the stack

If any of the arguments is -1 then that item is left unchanged.

Changing the screen resolution once the AES has been installed is
not supported, unless you no longer require its services.

You are recommended to clear the logical screen once its address
is changed, to ensure that all the VDI's pointers are up to date.
}
T:Ssbrk - Reserve System Memory
An obsolete function used with RAM-loaded TOS's.
No longer reequired.
}
T:Supexec - Execute A Function In Supervisor Mode
This function can be used to execute another function while in
supervisor mode.

  move.laddress,-(sp)Address of function to execute
  move.w#$26,-(sp)Function number $26
  trap#14Xbios trap number
  addq.l#6,spTidy the stack

The function executed should try and avoid calling the;
L:Bios:5;
or Xbios
as they are not truely re-entrant.

The value returned from the executed function is passed back through
Supexec.

The executed function should end with an RTS instruction.
}
T:Vsync - Wait For The Next Vertical Blank
This function is used to wait until the next vertical blank.

  move.w#$25,-(sp)Function number $25
  trap#14Xbios trap number
  addq.l#2,spTidy the stack
}
T:Xbtimer - Configure MFP Timer
This function is used to start up one of the;
L:68901's:12;
timers.

  move.lvector,-(sp)Address of interrupt routine
  move.wdata,-(sp)Value placed in to data register
  move.wcontrol,-(sp)Value placed in to control register
  move.wtimer,-(sp)Timer to use, A=0, B=1, C=2, D=3
  move.w#$1F,-(sp)Function number $1F
  trap#14Xbios trap number
  add.l#12,spTidy the stack

The timers have the following uses

  ADMA sound counter
  BHblank counter
  C200Hz system timer
  DRS-232 baud rate generator
}
T:The Gemdos
Within this section each of the Gemdos function is described. Each
description will show the arguments that have to be placed on the
stack in the order that they are placed. Return values are detailed
along with stack tidying requirements.

The Gemdos is accessed through TRAP vector number 1. The registers
D0-D4 and A0-A4 may be changed during a Gemdos call, and should be
saved by a users program if their contents  will be required later.

  ;
L:Cauxin:74;
;
L:Cauxis:75;
;
L:Cauxos:76;
;
L:Cauxout:77;
  ;
L:Cconin:78
  ;
L:Cconis:79;
;
L:Cconos:80;
;
L:Cconout:81;
  ;
L:Cconrs:82;
;
L:Cconws:83
  ;
L:Cnecin:84;
;
L:Cprnos:85;
;
L:Cprnout:86;
  ;
L:Crawcin:87;
  ;
L:Crawio:88
  ;
L:Dcreate:89;
  ;
L:Ddelete:90;
  ;
L:Dfree:91;
;
L:Dgetdrv:92;
  ;
L:Dsetdrv:93
  ;
L:Dgetpath:94;
 ;
L:Dsetpath:95;
 ;
L:Fattrib:96;
  ;
L:Fclose:97;
;
L:Fcreate:98
  ;
L:Fdatime:99;
  ;
L:Fdelete:100;
  ;
L:Fdup:101;
;
L:Fforce:102;
;
L:Fgetdta:103
  ;
L:Fsetdta:104;
  ;
L:Fopen:105;
;
L:Fread:106;
;
L:Frename:107;
  ;
L:Fseek:108
  ;
L:Fsfirst:109;
  ;
L:Fsnext:110;
;
L:Fwrite:111;
;
L:Malloc:112;
;
L:Mfree:113
  ;
L:Mshrink:114;
  ;
L:Pexec:115;
;
L:Pterm:116;
;
L:Pterm0:117;
;
L:Ptermres:118
  ;
L:Super:119;
;
L:Sversion:120;
 ;
L:Tgetdate:121;
 ;
L:Tsetdate:122;
 ;
L:Tgettime:123
  ;
L:Tsettime:124
}
T:Cauxin - Read A Character From The Auxiliary Port
This function reads a character from the ST's RS-232 port
and places it in the low order byte of D0 on return.

  move.w#$3,-(sp)Function number $3
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The use of this function is not recommended, use;
L:Bconin:25;
instead.
}
T:Cauxis - Check Status Of The Auxiliary Input
This function checks the input status of the ST's RS-232 port.
A return value of -1 indicates that at least one character is
available, otherwise the return is 0.

  move.w#$12,-(sp)Function number $12
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The use of this function is not recommended, use;
L:Bconstat:23;
instead.
}
T:Cauxos - Check Status Of The Auxiliary Output
This function checks the output status of the ST's RS-232 port.
A return value of -1 indicates that at least one character can
be sent, otherwise the return is 0.

  move.w#$13,-(sp)Function number $13
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The use of this function is not recommended, use;
L:Bcostat:24;
instead.
}
T:Cauxout - Write A Character To The Auxiliary Port
This function writes a character to the ST's RS-232 port.

  move.wchar,-(sp)Character to output
  move.w#$4,-(sp)Function number $4
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

The use of this function is not recommended, use;
L:Bconout:26;
instead.
}
T:Cconin - Read And Echo A Character From The Keyboard
This function reads a character from the ST's keyboard, echoing
it to the screen and placing the return value in D0.

  move.w#$1,-(sp)Function number $1
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The return value has the following format

Bits 24-31Shift key status, see;
L:Kbshift:32
16-23Keyboard scan code
8-15Unused
0-7ASCII code

The shift key status will only be included if bit three of the
system variable conterm is set.
}
T:Cconis - Check Status Of The Keyboard
This function checks the input status of the ST's keyboard.
A return value of -1 indicates that at least one character is
available, otherwise the return is 0.

  move.w#$B,-(sp)Function number $B
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack
}
T:Cconos - Check Status Of The Screen
This function checks the output status of the screen.
A return value of -1 indicates that at least one character can
be sent, otherwise the return is 0.

  move.w#$10,-(sp)Function number $10
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack
}
T:Cconout - Write A Character To The Screen
This function writes a character to the screen.

  move.wchar,-(sp)Character to output
  move.w#$2,-(sp)Function number $2
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack
}
T:Cconrs - Read A String From The Keyboard
This function reads a string from the keyboard until the return
key is pressed.

  move.lbuffer,-(sp)Buffer to store string
  move.w#$A,-(sp)Function number $A
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

The parameter 'buffer' should be formed as shown
  $0Maximum number of characters to read
  $1On return contains the number of characters actually read
  $2The read string actually starts here

Some control key combinations have special effects with this call
  Control CCancel input and terminate program
  Control HBackspace and delete last character
  Control J/MEnd input, do not place control J/M in buffer
  Control REcho input line and continue entry
  Control UEcho input line and restart entry
  Control XCancel input line and restart entry
}
T:Cconws - Write A String To The Screen
This function can be used to output a null-terminated string to the
screen. On return D0 contains the number of characters output.

  move.lpointer,-(sp)Pointer to the string to write
  move.w#$9,-(sp)Function number $9
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack
}
T:Cnecin - Cooked Input From The Keyboard
This function returns a keypress without echo.
It checks for special control keys. The return
value is exactly the same as for Cconin.

  move.w#$8,-(sp)Function number $8
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack
}
T:Cprnos - Check Ouput Status Of The Printer
This function checks the output status of the ST's parallel port.
A return value of -1 indicates that at least one character can
be sent, otherwise the return is 0.

  move.w#$11,-(sp)Function number $11
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack
}
T:Cprnout - Write A Character To The Parallel Port
This function writes a character to the parallel port.

  move.wchar,-(sp)Character to output
  move.w#$5,-(sp)Function number $5
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

The return value in D0 indicates if the character was
successfully output,(-1), or not,(0).
}
T:Crawcin - Raw Input From The Keyboard
This function returns a keypress without echo.
It does not check for special control keys.
The return value is exactly the same as for Cconin.

  move.w#$7,-(sp)Function number $7
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack
}
T:Crawio - Raw I/O With Console Devices
This function can be used to either output a single
character to the screen or input a single character
from the keyboard.

  move.wfunc,-(sp)Mode of operation
  move.w#$6,-(sp)Function number $6
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

If the 'func' parameter is given the value $FF then the
keyboard will be tested, and if there is a character
available, it will be returned in the same format as
Cconin. If there is no character available 0 will be
returned.

If 'func' is not $FF then the character with the value
'func' will be sent to the screen.

Special keys, (control-C etc.), are not checked when
using this function.
}
T:Dcreate - Create A Gemdos Folder/Directory
This function is used to create a folder or directory.

  move.lpathname,-(sp)  Null-terminated pathname
  move.w#$39,-(sp)Function number $39
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

The function returns with a 0 in D0 if the operation was
completed successfully, or a;
L:negative error:20;
number otherwise.
}
T:Ddelete - Delete A Gemdos Folder/Directory
This function is used to delete a folder or directory.

  move.lpathname,-(sp)  Null-terminated pathname
  move.w#$3A,-(sp)Function number $3A
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

The function returns with a 0 in D0 if the operation was
completed successfully, or a;
L:negative error:20;
number otherwise.
Note that it is not possible to delete a directory that
contains files. Fdelete should be used to remove the files
first.
}
T:Dfree - Get Free Disk Space
This function can be used to determine the amount of space
available on the specified drive.

  move.wdev,-(sp)Device, 0=current 1=A 2=B etc.
  move.lbuffer,-(sp)Buffer for return information
  move.w#$36,-(sp)Function number $36
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

The buffer for the return information has the following format

  $0freeNumber of free clusters
  $4cpdTotal number of clusters
  $8bpsBytes per sector
  $CspcSectors per cluster

The function returns 0 upon successful completion or a;
L:negative:20
L:error:20;
number.

NOTE: This function is VERY slow on pre-1.4 TOS's
}
T:Dgetdrv - Get The Current Default Drive
This function can be used to determine which drive will be
used by default.

  move.w#$19,-(sp)Function number $19
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The function returns a number corresponding to the current
default device, A=0, B=1 etc.
}
T:Dsetdrv - Set The Current Default Drive
This function is used to set the current default drive.

  move.wdev,-(sp)Default device, A=0, B=1 etc.
  move.w#$E,-(sp)Function number $E
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

The return in D0 is a bitmap of the currently available
devices, similar to;
L:Drvmap.:31
}
T:Dgetpath - Get The Current Default Path
This function is used to determine the current default
path on the specified device.

  move.wdev,-(sp)Device, current=0, A=1, B=2 etc,.
  move.lbuffer,-(sp)Buffer to place pathname
  move.w#$47,-(sp)Function number $47
  trap#1Gemdos trap number
  addq.l#8,spTidy the stack

The return value in D0 will be 0 to indicate success or a
L:negative error:20;
number.

The buffer should be at least 64 bytes long. The pathname placed
in the buffer by the function is null-terminated.
}
T:Dsetpath - Set The Current Default Path
This function is used to set the default path on the current
default device.

  move.lbuffer,-(sp)Buffer with null-terminated pathname
  move.w#$3B,-(sp)Function number $3B
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

The path for a specified device can be set by including the
device letter followed by a colon at the beginning of the
pathname, but this can cause 'confuse' and should be avoided
if at all possible.

A return value of 0 indicates success, while negative returns
are;
L:errors.:20
}
T:Fattrib - Get Or Set File Attributes
This function can be used to determine or set the attributes
of a specified file.

  move.wattrib,-(sp)File attributes
  move.wmode,-(sp)Mode of operation, 0=get 1=set
  move.lpathname,-(sp)  Address of null-terminated filename
  move.w#$43,-(sp)Function number $43
  trap#1Gemdos trap number
  add.l#10,spTidy the stack

The attrib parameter is a bitmap arranged as shown
  0Read-only flag
  1Hidden file flag
  2System file flag
  3Volume label flag
  4Subdirectory flag
  5Archive flag
 6-7Reserved

The function returns the old attributes if successful, or a;
L:negative:20
L:error:20;
code.
}
T:Fclose - Close A Gemdos File
This function is used to close the specified Gemdos file.

  move.whandle,-(sp)Gemdos file handle
  move.w#$3E,-(sp)Function number $3E
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

This function returns 0 if completed successfully, or a;
L:negative:20
L:error:20;
code.
}
T:Fcreate - Create Or Truncate A Gemdos File
This function is used to create or truncate an existing Gemdos
file to zero length.

  move.wmode,-(sp)Mode to open file in
  move.lfilename,-(sp)  Address of null-terminated filename
  move.w#$3C,-(sp)Function number $3C
  trap#1Gemdos trap number
  addq.l#8,spTidy the stack

The 'mode' parameter is a bitmap with the following settings
  0Read-only flag
  1Hidden file flag
  2System file flag
  3Volume label flag
  4Unused
  5Archive flag
 6-7Unused

The function returns with a word length handle if successful, or
a longword;
L:negative error:20;
code if not.
}
T:Fdatime - Get Or Set A File Time Stamp
This function can be used to determine or set the time stamp on
a specified file.

  move.wmode,-(sp)Mode of operation, 0=get, 1=set
  move.whandle,-(sp)Gemdos file handle
  move.lbuffer,-(sp)Address of buffer holding time
  move.w#$57,-(sp)Function number $57
  trap#1Gemdos trap number
  add.l#10,spTidy the stack

The buffer consists of two words formatted as shown
Bits 0-4Day, 1-31
5-8Month, 1-12
9-15Year minus 1980, 0-127
Bits 0-4Seconds / 2, 0-29
5-10Minutes, 0-59
11-15Hours, 0-23

The function returns 0 upon successful sompletion or a;
L:negative:20
L:error:20;
number.
}
T:Fdelete - Delete A Named Gemdos File
This function can be used to delete a named Gemdos file.

  move.lfilename,-(sp)  Null-terminated filename
  move.w#$41,-(sp)Function number $41
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

This function returns 0 if completed successfully, or a;
L:negative:20
L:error:20;
value.

The function can be used to delete an open file. The file will
be closed and then deleted. However the handle is not released
and will not become available.
}
T:Fdup - Duplicate A Standard File Handle
This function can be used to create a duplicate handle for one
of the standard devices.

  move.wstandard,-(sp)  Standard handle, 0-5
  move.w#$45,-(sp)Function number $45
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

The return value will either be a positive file handle refering to
the standard device, or a;
L:negative error:20;
code.

Handles generated with this function should be released with Fclose.
}
T:Fforce - Redirect A Standard File Handle
This function is used to force one of the standard device handles
to refer to a specified file handle.

  move.wnstdh,-(sp)Non-standard handle
  move.wstdh,-(sp)Standard handle, 0-5
  move.w#$46,-(sp)Function number $46
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

This function returns 0 if successful, or a;
L:negative error:20;
code
otherwise.
}
T:Fgetdta - Get The Data Transfer Address
This function returns a pointer to the current Data Transfer Address.

  move.w#$2F,-(sp)Function number $2F
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The complementary function to set the address of a DTA is Fsetdta.
}
T:Fsetdta - Set The Data Transfer Address
This function allows you to set the current Data Transfer Address.

  move.lpointer,-(sp)Address of 44-byte DTA
  move.w#$1A,-(sp)Function number $1A
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

The complementary function to get the address of a DTA is Fgetdta.
}
T:Fopen - Open A Gemdos File
This function can be used to open a Gemdos file for reading
and/or writing.

  move.wmode,-(sp)Mode, 0=Read 1=Write 2=Read/Write
  move.lfilename,-(sp)  Address of null-terminated filename
  move.w#$3D,-(sp)Function number $3D
  trap#1Gemdos trap number
  addq.l#8,spTidy the stack

This function returns a positive file handle if successful, or a
longword;
L:negative error:20;
code.

In addition to standard filenames, 'con:', 'aux:' and 'prn:' are
recognised as the console, auxiliary device, (RS-232), and printer.

To create a new file use the Fcreate function. To close an open file
use the Fclose function.
}
T:Fread - Read From An Open Gemdos File
This function is used to read a number of bytes from a
previously opened file.

  move.lbuffer,-(sp)Buffer to read in to
  move.lcount,-(sp)Count of number of bytes to read
  move.whandle,-(sp)File handle
  move.w#$3F,-(sp)Function number $3F
  trap#1Gemdos trap number
  add.l#12,spTidy the stack

The function returns the number of bytes read without error,
or a;
L:negative error:20;
code if a serious error occurs.
}
T:Frename - Rename An Existing File Or Folder
This function allows you to rename a file or, (if you have TOS
1.4 or higher), a folder.

  move.lnewname,-(sp)Address of null-terminated new filename
  move.loldname,-(sp)Address of null-terminated old filename
  clr.w-(sp)Zero parameter
  move.w#$56,-(sp)Function number $56
  trap#1Gemdos trap number
  add.l#12,spTidy the stack

Files may be moved in to different directories by changing their name.
This does not apply to folders.

The function returns 0 if successful or a;
L:negative error:20;
code.
}
T:Fseek - Move To A New Position In An Open File
This function allows you to move the file pointer in any
open file. That is, change the place where the next read
or write occurs.

  move.wmode,-(sp)Mode of operation
  move.whandle,-(sp)Handle of the file to use
  move.wposition,-(sp)  New offset
  move.w#$42,-(sp)Function number $42
  trap#1Gemdos trap number
  add.l#10,spTidy the stack

The mode may be any of
  0Seek from the beginning of the file to 'position'
  1Move forwards by the number of bytes in 'position'
  2Seekk from the end of the file 'position' byte back.

In mode 0, position must be 0 or positive, in mode 1 is it positive
or negative and in mode 2 it should be negative or zero.

This function returns the new position of the file pointer, relative
to the beginning of the file, or a;
L:negative error:20;
code.
}
T:Fsfirst - Find First Directory Entry
This function finds the first file that matches your search criteria.

  move.wattrib,-(sp)File attributes to search for
  move.lfilename,-(sp)  Address of filename to search for
  move.w#$4E,-(sp)Function number $4E
  trap#1Gemdos trap number
  addq.l#8,spTidy the stack

The 'attrib' parameter specifies which attributes matching files
should have. It is a bitmap set up as follows
  0Read-only flag3Volume label flag
  1Hidden file flag4Subdirectory flag
  2System file flag

The filename can include a drive and pathname and when specifying
a filename match criteria the special symbols '*' and '?' to match
a number of characters and a single character respectively. Fsnext
is used to find subsequent files.

The function returns 0 if successful, or a;
L:negative error:20;
code.
Information about any matched file is foudn in the DTA.
}
T:Fsnext - Find Subsequent Directory Entries
This function is used after Fsfirst to find subsequent files matching
a particular search criteria.

  move.w#$4F,-(sp)Function number $4F
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The search criteria used for Fsfirst will be used for Fsnext.

This function will return 0 if a file has been found, the DTA should
be examined to find details, or;
L:error code -49:20;
if no more files in
this directory match, or some other;
L:negative error:20;
code.
}
T:Fwrite
T:Fwrite - Write To An Open Gemdos File
This function is used to write a number of bytes to a
previously opened file.

  move.lbuffer,-(sp)Buffer to write from
  move.lcount,-(sp)Count of number of bytes to read
  move.whandle,-(sp)File handle
  move.w#$40,-(sp)Function number $40
  trap#1Gemdos trap number
  add.l#12,spTidy the stack

The function returns the number of bytes written without error,
or a;
L:negative error:20;
code if a serious error occurs. If the disk
is filled by this call it is indicated by the return value not
equalling the 'count' parameter. No explicit error message is
returned.
}
T:Malloc - Persuade Gemdos To Allocate A Block Of Memory
This function is used to allocate memory from Gemdos' pool, and
determine the largest free memory block.

  move.lnum,-(sp)Bytes to allocate
  move.w#$48,-(sp)Function number $48
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

If -1 is passed as the 'num' parameter then the largest free memory
block will be returned.

If a block was requested and available then the address of the block
will be returned otherwise 0.L will be returned.

Versions 1.0 and 1.2 of TOS have a limit of 20 blocks per process and
will crash violently if exceeded. TOS 1.4 is slightly better behaved.

Freeing allocated blocks can be done with function Mfree.
}
T:Mfree - Free A Previously Allocated Memory Block
The function is used to free a memory block that was previously
allocated with the function Malloc.

  move.laddress,-(sp)Address of allocated block
  move.w#$49,-(sp)Function number $49
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

The function returns 0 if it succeeded or a;
L:negative error:20;
code.
}
T:Mshrink - Shrink A Previously Allocated Memory Block
This function can be used to reduce the size of a block of memory
previously allocated with Malloc.

  move.lsize,-(sp)Size of new block
  move.lstart,-(sp)Address of block
  clr.w-(sp)Zero parameter
  move.w#$4A,-(sp)Function number $4A
  trap#1Gemdos trap number
  add.l#12,spTidy the stack

This function returns 0 if completed successfully or a;
L:negative:20
L:error:20;
code.

This function cannot be used reliably to increase the size of
a memory block.
}
T:Pexec - Create Or Execute A Process
This function provides facilities to create program basepages,
load programs and then execute them.

  move.lenv,-(sp)Environment string
  move.lcom,-(sp)Command line
  move.lfilename,-(sp)  Filename
  move.wmode,-(sp)Mode of operation
  move.w#$4B,-(sp)Function number $4B
  trap#1Gemdos trap number
  add.l#16,spTidy the stack

The 'com' parameter is the address of a length prefixed string
giving the command line to pass to the program.

The 'env' parameter is the address of the environment to pass to the
program. If this is 0.L the current processes environment is copied
and passed on.

The 'mode' parameter is described on the next page :-)
}
T:Pexec mode parameter
The 'mode' parameter can take any of the meanings below

  0Create a basepage, load a program in to this basepage and execute
the program. Returning its exit code as the functions return code.

  3Create a basepage and laod a program in to it. Return the address
of this basepage as the functions return code.

  4Execute a program already loaded. 'filename' and 'env' are unused.
'cmd' holds the address of the basepage to use. Return the exit
code of the program as the functions return value. The memory for
'env' and the TPA are not freed on exit.

  5Create a blank basepage. 'filename' and 'cmd' are unused. 'env'
has its usual meaning. The return value is the address of the
basepage created.

  6Identical to mode 4 above, however any memory used is returned
once the program has terminated. This mode is only available on
TOS 1.4 and above, so go and buy a copy now.
}
T:The Smiley :-)
Put your head on your left shoulder when you look at this.

&:-)

Used to indicate humour. Often used where offense may be
caused because pure text is a poor communication medium.

Variations exist to indicate other frames of mind.
}
T:Pterm - Terminate This Process
This function is used to immediately terminate this process.

  move.wretcode,-(sp)Return code
  move.w#$4C,-(sp)Function number $4C
  trap#1Gemdos trap number

'retcode' is a word sized value that is passed back to the calling
process.

A call through the extended vector etv_term is made just prior to
termination. All files are closed and all memory returned to the
OS pool.
}
T:Pterm0 - Terminate This Process
This function is used to immediately terminate this process.

  clr.w-(sp)Function number $0
  trap#1Gemdos trap number

This function passes the value 0 back to its calling process.

A call through the extended vector etv_term is made just prior to
termination. All files are closed and all memory returned to the
OS pool.
}
T:Ptermres - Terminate And Stay Resident
This function is used when terminating a process that you wish
to keep resident.

  move.wretcode,-(sp)Code to return to calling process
  move.lkeep,-(sp)Number of bytes to keep
  move.w#$31,-(sp)Function number $31
  trap#1Gemdos trap number

This function is similar to Pterm but all memory allocated to the
process by Malloc is kept. The 'keep' parameter indicates the number
of bytes of memory, starting at the beginning of the basepage, to
retain.

Memory taken by a TSR process is lost forever.

All files are closed upon the Pterm part of the function.
}
T:Super - Get, Set or Inquire Of Supervisor Mode
This function allows you to enter, leave or determine whether the
processor is in supervisor mode.

  move.lmode,-(sp)Mode of operation
  move.l#$20,-(sp)Function number $20
  trap#1Gemdos trap number
  addq.l#6,spTidy the stack

If 'mode' is set to 0.L then supervisor mode is entered and the
value of the old supervisor stack returned in D0.L

If 'mode' is not 0.L then the value is taken to be an old
supervisor stack and placed in the supervisor stack pointer. The
processor is returned to user mode.

If 'mode' is 1.L then the return value will be 0 if the processor
is in user mode, or 1 if in supervisor mode.

You cannot call the AES from supervisor mode!
}
T:Sversion - Return Gemdos Version Number
This function is used to determine the version of Gemdos currently
installed.

  move.w#$30,-(sp)Function number $30
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The version number is returned in a byte-swapped word. Values in use
to date are.

  19 00ROM TOS, (1.0), BLiTTER TOS, (1.2)
  21 00Rainbow TOS, (1.4), STE TOS, (1.6)
}
T:Tgetdate - Get The Gemdos Date
This function is used to determine the current Gemdos date.

  move.w#$2A,-(sp)Function number $2A
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The date is returned packed in to a word with the following layout

Bits 0-4Day, 0-31
5-8Month, 1-12
9-15Year minus 1980, 0-127
}
T:Tsetdate - Set The Gemdos Date
This function is used to set the current Gemdos date.

  move.wdate,-(sp)Word packed with date information
  move.w#$2B,-(sp)Function number $2B
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

The format of the 'date' word is exactly as shown under Tgetdate.

This function returns value 0 if successful, or a;
L:negative error:20;
code
if an obviously incorrect date is supplied.
}
T:Tgettime - Get The Gemdos Time
This function is used to determine the current Gemdos time.

  move.w#$2C,-(sp)Function number $2C
  trap#1Gemdos trap number
  addq.l#2,spTidy the stack

The time is returned packed in to a word with the following layout

Bits 0-4Second / 2, 0-29
5-10Minute, 0-59
11-15Hour, 0-23
}
T:Tsettime - Set The Gemdos Time
This function is used to set the current Gemdos time.

  move.wtime,-(sp)Word packed with time information
  move.w#$2D,-(sp)Function number $2D
  trap#1Gemdos trap number
  addq.l#4,spTidy the stack

The format of the 'time' word is exactly as shown under Tgettime.

This function returns value 0 if successful, or a;
L:negative error:20;
code
if an obviously incorrect time is supplied.
}
T:The AES
Brief details of each of the
AES functions are given in this
section. The required arguments
will be listed with any results
that are returned. For calling
details I would recommend that
you examine the books mentioned
in the bibliography.

;
L:Application Library:125
;
L:Event Library:126
;
L:Menu Library:127
;
L:Object Library:128
;
L:Form Library:129
;
L:Graphics Library:130
;
L:Scrap Library:131
;
L:File Selector:132
;
L:Windows Library:133
;
L:Resource Library:134
;
L:Shell Library:135
}
T:AES - Application Library
The application library contains functions that
control the use of other AES libraries and allow
a certain degree of communication between different
applications.

;
L:appl_exit:176;
;
L:appl_find:177
;
L:appl_init:178;
;
L:appl_read:179
;
L:appl_tplay:180;
  ;
L:appl_trecord:181
;
L:appl_write:182
}
T:AES - appl_exit
Calling this function allows the application library
to cleanup the environment when an application has
finished making AES calls.

Op: 19
intout(0) : 0 = error
>0 = ok
}
T:AES - appl_find
This function allows you to find the application
identifier of another application in the system.

Op: 13
intout(0) : application identifier
-1 = not found
addrin(0) : null-terminated filename,
8 characters long, blank filled.
}
T:AES - appl_init
This function initialises some global areas used by the
AES and should be called before any other calls are made
to the AES.

Op: 10
intout(0) : application identifier
-1 = error, terminate immediately!
}
T:AES - appl_read
This function will read a specified number of
bytes from a message pipe in to a user specified
buffer.

Op: 11
intin(0)  : application identifier of message pipe owner
intin(2)  : number of bytes to read
intout(0) : 0 = error
>0 = ok
addrin(0) : address of buffer to receive message
}
T:AES - appl_tplay
This function plays back a series of events previously
recorded using appl_trecord.

Op: 14
intin(0)  : number of events to play
intin(2)  : speed of replay, (1-10000), 50 = half,
6100 = full,
6200 = double.
intout(0) : 1
addrin(0) : address of buffer holding recording
}
T:AES - appl_trecord
This function is used to record a series of events that can then
be played back using appl_tplay.

Op: 15
intin(0)  : number of events to record
intout(0) : number actually recorded
addrin(0) : address of buffer to hold recording

Each recoding of an event takes 8 bytes. The event is stored in
the following way.

1st Longword"2nd Longword
  0 = timer eventelapsed time in milliseconds
  1 = button eventlow word : 0=up, 1=down,
0high word: number of clicks
  2 = mouse eventlow word : x coordinate
0high word: y coordinate
  3 = keyboard eventlow word : key code
0high word: shift key state
}
T:AES - appl_write
This function is used to write a specified number of bytes
to the message pipe of a specified application.

Op: 12
intin(0)  : application identifier of message pipe owner
intin(2)  : number of bytes to write
intout(0) : 0 = error
>0 = ok
addrin(0) : address of buffer holding data to write
}
T:AES - Event Library
The event library contains functions that
respond to inputs from the user and other
system components. For example, messages,
mouse clicks and menu selections.

;
L:evnt_button:183;
  ;
L:evnt_dclick:184
;
L:evnt_keybd:185;
;
L:evnt_mesag:186
;
L:evnt_mouse:187;
;
L:evnt_multi:188
;
L:evnt_timer:189
}
T:AES - evnt_button
This function is used to wait for a certain event
to happen with regard to the mouse buttons. When this
event occurs the final state of the buttons is returned.

Op: 21
intin(0)  : maximum number of clicks to wait for
intin(2)  : mask of buttons to wait for
intin(4)  : button state to wait for
intout(0) : Number of clicks that actually occurred
intout(2) : x coordinate of mouse on event
intout(4) : y coordinate of mouse on event
intout(6) : button state
intout(8) : shift key status

The mask is bit 0 for the left button and bit 1 for the right button.
The state is 0 for up and 1 for down.
The shift key status is bit 0 right shift
*1 left shift
*2 control
*3 alternate
}
T:AES - evnt_dclick
This function is used to read or set the mouse
double click speed.

Op: 26
intin(0)  : new speed, slow = 0, fast = 4
intin(2)  : 0 = get
1 = set
intout(0) : New double click speed,
this will also be the old one if intin(2)=0
}
T:AES - evnt_keybd
This function is used to wait for a key press.

Op: 20
intout(0) : Key code, low byte is the ASCII code
#high byte is the scan code.

See Keyboard Codes for more details.
}
T:AES - evnt_mesag
This function is used to wait for a message event.

Op: 23
intout(0) : Reserved, (=1)
addrin(0) : Address of an 8 word buffer where return information
should be placed.

The information placed in this buffer will change dependent upon
which message event actually occurred.

In all cases though the first word of the buffer contains the
message type, the second contains the application identifier of
apllication that sent the message and the third contains the
length of the message, not including the initial 16 bytes.

Message types are
  10  Menu selected23  Full window27  Resize window
  20  Window redraw24  Scroll window28  Move window
  21  Top window25  Horiz. slider29  New active window
  22  Close window26  Vertical slider40  Open accessory
:41  Close accessory
}
T:Message - Menu Selected
The format of the message when a menu selected message
is passed is as follows

  Word  Meaning
  3The object number of the menu title selected
  4The object number of the item selected
}
T:Message - Window Redraw
The format of the message when a redraw window message
is passed is as follows

  Word  Meaning
  3Handle of the window to redraw
  4X coordinate of area to redraw
  5Y coordinate of area to redraw
  6Width of area to redraw
  7Height of are to redraw
}
T:Message - Top Window
The format of the message when a window topped message
is passed is as follows

  Word  Meaning
  3Handle of the window topped
}
T:Message - Close Window
The format of the message when a close window message
is passed is as follows

  Word  Meaning
  3Handle of the window to be closed
}
T:Message - Full Window
The format of the message when a full window message
is passed is as follows

  Word  Meaning
  3Handle of the window to be fulled
}
T:Message - Scroll Window
The format of the message when a scroll window message
is passed is as follows

  Word  Meaning
  3Handle of the window affected
  4Action requested, 0  Page up
(1  Page down
(2  Page left
(3  Page right
(4  Row up
(5  Row down
(6  Column left
(7  Column right
}
T:Message - Sliders
The format of the message when a slider moved message
is passed is as follows

  Word  Meaning
  3Handle of the window affected
  4New position of the slider, 0 - 1000,
20= left/top
21000 = right/bottom
}
T:Message - Resize Or Move Window
The format of the message when a resize or move message
is passed is as follows

  Word  Meaning
  3Handle of the window to be changed
  4X coordinate of the new window
  5Y coordinate of the new window
  6Width of the new window
  7Height of the new window
}
T:Message - Activate Window
The format of the message when an activate window message
is passed is as follows

  Word  Meaning
  3Handle of window activated
}
T:Message - Open Accessory
The format of the message when an open accessory message
is passed is as follows

  Word  Meaning
  3Desk accesory menu identifier, see menu_register
}
T:Message - Close Accessory
The format of the message when a close accessory message
is passed is as follows

  Word  Meaning
  3Desk accesory menu identifier, see menu_register

Note that when in receipt of a close accessory message you
should not try to close and/or delete and windows that you
may have opened in the accessory. This will be done auto-
matically. All you have to do is adjust any internal flags
that you may have indicating the state of your windows
}
T:AES - evnt_mouse
This function can be used to wait for the mouse pointer
to enter or leave a sepcified rectangle.

Op: 22
intin(0)  : flag, 0 = return on entering rectangle
 1 = return on leaving rectangle
intin(2)  : X coordinate of rectangle
intin(4)  : Y coordinate of rectangle
intin(6)  : Width of rectangle
intin(8)  : Height of rectangle
intout(0) : Reserved, (=1)
intout(2) : X coordinate of mouse on event
intout(4) : Y coordinate of mouse on event
intout(6) : Button state on event, see evnt_button
intout(8) : Shift key state on event, see evnt_button
}
T:AES - evnt_multi
This function is used to wait for a number of events that may happen
in any order or simultaneously.

Op: 25
intin(0): Bitmap of events to wait for
intin(2): Maximum number of mouse clicks }
intin(4): Mask of buttons to wait for} See evnt_button
intin(6): Button state to wait for}
intin(8): Rectangle 1 enter/leave flag  }
intin($A)  :X coordinate}
intin($C)  :Y coordinate}
intin($E)  :Width}
intin($10) :Height} See evnt_mouse
intin($12) : Rectangle 2 enter/leave flag  }
intin($14) :X coordinate}
intin($16) :Y coordinate}
intin($18) :Width}
intin($1A) :Height}
intin($1C) : Timer low word  } milliseconds
intin($1E) : Timer high word } See evnt_timerintout-->
}
T:Evnt_multi Continued
intout(0) : Bitmap of events that actualy occurred
intout(2) : Mouse X coordinate on event
intout(4) : Mouse Y coordinate on event
intout(6) : Mouse button state on event
intout(8) : Shift key status on event, see evnt_button
intout($A): Key scan code
intout($C): Number of mouse clicks

The different event types have the following allocation in the
bitmaps

Bit 0Keyboard event
1Button event
21st Rectangle
32nd Rectangle
4Message event
5Timer event
}
T:AES - evnt_timer
This function tells the AES to wait for a specific
amount of time to pass.

Op: 24
intin(0)  : Low word of time in milliseconds
intin(2)  : high word of time in millisecons
intout(0) : Reserved, (=1)
}
T:AES - Menu Library
The menu library contains functions that
control the operation and appearance of the
pull-down menus. Installing menus, disabling
or checking items for example.

;
L:menu_bar:190;
;
L:menu_icheck:191
;
L:menu_ienable:192;
;
L:menu_register:193
;
L:menu_text:194;
;
L:menu_tnormal:195
}
T:AES - menu_bar
This function is used to install or remove a menu bar.

Op: 30
intin(0)  : flag, 0 = erase the menu
 1 = draw the menu
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree that forms the menu
}
T:AES - menu_icheck
This function is used to place or remove a check mark
against an item in a menu bar.

Op: 31
intin(0)  : menu item identifier, (obtained from resource constructor)
intin(2)  : flag, 0 = clear check mark
 1 = display check mark
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree that forms the menu
}
T:AES - menu_ienable
This function is used to enable or disable a particular
option in a menu bar.

Op: 32
intin(0)  : menu item identifier, (obtained from resource constructor)
intin(2)  : flag, 0 = disabled
 1 = enabled
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree that forms the menu

On TOS 1.2 and later it is also possible to disable menu titles as
well as menu items.
}
T:AES - menu_register
This function is used by a desk accessory that wants
to insert its own title in the Desk menu.

Op: 35
intin(0)  : Desk accessory application identifier
intout(0) : Menu item identifier
addrin(0) : Address of a null-terminated string that contains the
text to place under the Desk menu.
}
T:AES - menu_text
This function is used to change the text of a
menu item. The new text should be no longer
than the old text.

Op: 34
intin(0)  : Menu item identifier
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the string that contains the new text
addrin(4) : Address of the object tree that forms the menu
}
T:AES - menu_tnormal
This function is used to change the representation of a
menu title, either to normal video or inverse video.

Op: 33
intin(0)  : menu title identifier, (obtained from resource constructor)
intin(2)  : flag, 0 = reverse video
 1 = normal video
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree that forms the menu
}
T:AES - Object Library
The object library contains functions that
allow for the low level manipulation of objects
within object trees. Drawing objects, changing
their state, deleting them and adding them for
example.

;
L:objc_add:196;
;
L:objc_change:197
;
L:objc_delete:198;
;
L:objc_draw:199
;
L:objc_edit:200;
;
L:objc_find:201
;
L:objc_offset:202;
;
L:objc_order:203
}
T:AES - objc_add
This function is used to add a child object in to a parent object tree.

Op: 40
intin(0)  : Index of the parent object
intin(2)  : Index of the object to be added
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree in to which the child is
to be added
}
T:AES - objc_change
This function is used to change the state of an object
and then possibly redraw it.

Op: 47
intin(0)  : Index of the object to change
intin(2)  : Reserved, = 0
intin(4)  : X coordinate of clipping rectangle to use in redraw
intin(6)  : Y coordinate of the same
intin(8)  : Width of the same
intin($A) : Height of the same
intin($C) : New value to be loaded in to the object state
intin($E) : Redraw flag, 0 = no redraw
'1 = redraw
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree that contains this object
}
T:AES - objc_delete
This function is used to delete an object from an object tree.

Op: 41
intin(0)  : Index of the object to be deleted
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree that contains this object
}
T:AES - objc_draw
This function is used to draw an object tree, or just a
part of an object tree.

Op: 42
intin(0)  : Index of the start object to draw
intin(2)  : Level that the draw should go to
intin(4)  : X coordinate of clipping rectangle to use in redraw
intin(6)  : Y coordinate of the same
intin(8)  : Width of the same
intin($A) : Height of the same
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree
}
T:AES - objc_edit
A function that is normally only used if you are implementing your own
version of the AES function, form_do. It allows for the editing of
text objects.

Op : 46
intin(0)  : Index of object to be edited
intin(2)  : The character that the use input
intin(4)  : Position of the cursor in the string
intin(6)  : Action to perform, 0 = Reserved
-1 = Format string using text/template
-2 = Validate against Tedinfo and display
-3 = Turn off text cursor
intout(0) : 0 = error
>0 = ok
intout(2) : Position of cursor after this operation
addrin(0) : Address of the object tree
}
T:AES - objc_find
this function is used to find the index of the object
under a specified X,Y point.

Op: 43
intin(0)  : Index of object to start search at
intin(2)  : Level of search
intin(4)  : X coordinate
intin(6)  : Y coordinate
intout(0) :-1 = no object found
0 to n = Index of the object found
addrin(0) : Address of the object tree
}
T:AES - objc_offset
This function is used to determine the X,Y position of an
object within an object tree. Usually an objects position
is specified relative to its parent object.

Op: 44
intin(0)  : Index of object in question
intout(0) : 0 = error
>0 = ok
intout(2) : X coordinate
intout(4) : Y coordinate
addrin(0) : Address of the object tree
}
T:AES - objc_order
This function can be used to move an object within
its list of sibling objects.

Op: 45
intin(0)  : Index of object to be moved
intin(2)  : New position to attain, 0 = 1st child, 1 = 2nd etc.
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the object tree
}
T:AES - Form Library
The form library contains functions
that deal with dialog boxes, the way
in which they are presented and how
the use may interact with them.

;
L:form_alert:204
;
L:form_center:206
;
L:form_dial:207
;
L:form_do:208
;
L:form_error:209
}
T:AES - form_alert
This function is used to diaply an alert box and
wait for the users response.

Op: 52
intin(0)  : Default exit button, 0 = no default
intout(0) : Button the user selected, 1 to 3
addrin(0) : Address of the null-terminated alert string.

The alert string is made up from three parts thus  "[A][B][C]"

A: This is a number representing the icon you want in the alert box.
0 = No icon,  1 = '!' icon,  2 = '?' icon,  3 = STOP icon.

B: This is the main text in the alert box. You may have up to 5 lines
of 30 characters each, separated by '|' characters. It is a good
idea to put padding spaces at the ends of the lines.

C: This is the text of the buttons, of which there may be three, each
with 10 characters. Again separate them with '|' characters.
}
T:AES - form_center
This function is used to centre the specified dialog
on the screen.

Op: 54
intout(0) : Reserved, (=1)
intout(2) : X coordinate of the centred dialog
intout(4) : Y coordinate of the same
intout(6) : Width of the same
intout(8) : Height of the same
addrin(0) : Address of the dialog box object tree.
}
T:AES - form_dial
This function is used to perform a number of different
operations on dialog boxes.

Op: 51
intin(0): flag, 0 = reserve screen space, use big box
!1 = draw an expanding box
!2 = draw a shrinking box
!3 = free reserved screen space, use big box
intin(2): X coordinate of small box
intin(4): Y coordinate
intin(6): Width
intin(8): Height
intin($A)  : X coorindate of big box
intin($C)  : Y coordinate
intin($E)  : Width
intin($10) : Height
intout(0)  : 0 = error
>0 = ok
}
T:AES - form_do
This function is used to monitor the interaction between a
user and a dialog box.

Op: 50
intin(0): Object to start at, that is 1st editable field or 0.
intout(0)  : Object number that caused the exit,
Bit 15 will be set if a double-click caused the exit.
addrin(0)  : Address of the object tree
}
T:AES - form_error
This function can be used to diaply a standard
Gemdos error alert box.

Op: 53
intin(0): DOS error code, those recognised
are 2, 3, 4, 5, 8, 10, 11, 15 and 18
intout(0)  : Exit button used, always 1.
}
T:AES - Graphics Library
The graphics library contains functions
deal with some of the graphical facilities
of the AES. For example, the form of the
mouse pointer and the manipulation of box
outlines are included in this library.

;
L:graf_dragbox:211
;
L:graf_growbox:212
;
L:graf_handle:213
;
L:graf_mkstate:214
;
L:graf_mouse:215
;
L:graf_movebox:216
;
L:graf_rubberbox:217
;
L:graf_shrinkbox:218
;
L:graf_slidebox:219
;
L:graf_watchbox:220
}
T:AES - graf_dragbox
This function can be used to let the user drag a box of fixed
size within another box of fixed size, the final position being
the return value.

Op: 71
intin(0)  : Width of the dragged box
intin(2)  : Height
intin(4)  : X coordinate
intin(6)  : Y coordinate
intin(8)  : X coordinate of the boundary box
intin($A) : Y coordinate
intin($C) : Width
intin($E) : Height
intout(0) : 0 = error
>0 = ok
intout(2) : Final X coordinate
intout(4) : Final Y coordinate
}
T:AES - graf_growbox
This function is used to draw a box 'growing' from an
intial position to a final bigger position.

Op: 73
intin(0)  : X coordinate of initial box
intin(2)  : Y coordinate
intin(4)  : Width
intin(6)  : Height
intin(8)  : X coordinate of the final box
intin($A) : Y coordinate
intin($C) : Width
intin($E) : Height
intout(0) : 0 = error
>0 = ok

The concensus of opinion seems to be that this function wastes
time and space and should only be used if it is giving necessary
information to the user.
}
T:AES - graf_handle
This function is used to return the VDI handle
that is being used by the AES.

Op: 77
intout(0) : VDI handle
intout(2) : Width of a character cell
intout(4) : Height of a character cell
intout(6) : Width of a box around a character
intout(8) : Height of a box around a character
}
T:AES - graf_mkstate
This function is used to return the current state of the mouse.

Op: 79
intout(0) : Reserved, (=1)
intout(2) : X coordinate of the mouse
intout(4) : Y coordinate of the mouse
intout(6) : State of the mouse buttons, see evnt_button
intout(8) : State of the shift keys, see evnt_button
}
T:AES - graf_mouse
This function is used to change the visual representation
of the mouse pointer.

Op: 78
intin(0)  : Mouse form, 0 = arrow6= thick cross hair
&1 = text cursor7= outline cross hair
&2 = bee255 = User-defined
&3 = pointing finger256 = hide mouse
&4 = flat hand257 = show mouse
&5 = thin cross hair
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of a 35 word buffer that defines the
mouse shape if the mouse type is 255, user-defined.
}
T:AES - graf_movebox
This function is used to draw a box 'moving' from an
intial position to a final position.

Op: 72
intin(0)  : Width of initial box
intin(2)  : Height
intin(4)  : X coordinate
intin(6)  : Y coordinate
intin(8)  : X coordinate of the final box
intin($A) : Y coordinate
intout(0) : 0 = error
>0 = ok

The concensus of opinion seems to be that this function wastes
time and space and should only be used if it is giving necessary
information to the user.
}
T:AES - graf_rubberbox
This function allows the user to drag a corner of a
rubberbox. The minimum width and height can be specified
and the final position is returned.

Op: 70
intin(0)  : X coordinate of box
intin(2)  : Y coordinate
intin(4)  : Minimum width
intin(6)  : Minimum height
intout(0) : 0 = error
>0 = ok
intout(2) : Width of final box
intout(4) : Height
}
T:AES - graf_shrinkbox
This function is used to draw a box 'shrinking' from an
intial position to a final smaller position.

Op: 74
intin(0)  : X coordinate of final box
intin(2)  : Y coordinate
intin(4)  : Width
intin(6)  : Height
intin(8)  : X coordinate of the initial box
intin($A) : Y coordinate
intin($C) : Width
intin($E) : Height
intout(0) : 0 = error
>0 = ok

The concensus of opinion seems to be that this function wastes
time and space and should only be used if it is giving necessary
information to the user.
}
T:AES - graf_slidebox
This function is used to allow the user to slide one box within
another. The sliding motion can be either horizontal or vertical.

Op: 76
intin(0)  : Index of the parent object
intin(2)  : Index of the object that is going to be sliding
intin(4)  : Direction of motion, 0 = horizontal
/1 = vertical
intout(0) : Final position, 0 = left/top, 1000 = right/bottom
addrin(0) : Address of the object tree containing parent and slider.
}
T:AES - graf_watchbox
This function is used to change the state of an object in
an object tree dependent upon the position of the mouse.

Op: 75
intin(0)  : Reserved
intin(2)  : Index of the object affected
intin(4)  : State it is to take with mouse in the box
intin(6)  : State it is to take with mouse outside
intout(0) : Position of the mouse upon button release, 0 = outside
E1 = inside
addrin(0) : Address of the object tree containing the object

This function should only be called when the mouse button is down
and the mouse pointer is inside the object.
}
T:AES - Scrap Library
The scrap library contains routines that
allow applications to pass information to
one another in the form of scrap files.

;
L:scrp_read:221;
;
L:scrp_write:222
}
T:AES - scrp_read
This function is used to discover the name of the current
scrap directory.

Op: 80
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of a buffer in to which the scrap directory
name is copied.
}
T:AES - scrp_write
This function is used to specify the name of the current
scrap directory.

Op: 81
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of a buffer from which the scrap directory
name is read.
}
T:AES - File Selectors
The file selector library contains
functions that allow the user to
select a file in an easy and
convenient manner.

;
L:fsel_exinput:223
;
L:fsel_input:224
}
T:AES - fsel_exinput
This function is used to allow the user to select a file
in an interactive and convenient manner using the extended
file selector of TOS versions 1.4 and above.

Op: 91
intout(0) : 0 = error
>0 = ok
intout(2) : Exit button, 0 = Cancel
'1 = Ok
addrin(0) : Address of the string that holds the initial directory
addrin(4) : Address of the string that holds the initial file
addrin(8) : Address of the string that is to be placed at the top
of the file selector dialog
}
T:AES - fsel_input
This function is used to allow the user to select a file
in an interactive and convenient manner using the standard
file selector.

Op: 90
intout(0) : 0 = error
>0 = ok
intout(2) : Exit button, 0 = Cancel
'1 = Ok
addrin(0) : Address of the string that holds the initial directory
addrin(4) : Address of the string that holds the initial file
}
T:AES - Window Library
The window library contains functions
that allow for the creation, deletion
and manipulation of windows.

;
L:wind_calc:225
;
L:wind_close:226
;
L:wind_create:227
;
L:wind_delete:228
;
L:wind_find:229
;
L:wind_get:230
;
L:wind_new:231
;
L:wind_open:232
;
L:wind_set:233
;
L:wind_update:234
}
T:AES - wind_calc
This function is used to calculate the area of a window. It can
calculate the working area if given the border size, and vice versa.

Op: 108
intin(0)  : Mode, 0 = work -> border,  1 = border -> work
intin(2)  : Bitmap of the window components,
Bit 0 Name4 Size box8  Left arrow
1 Close box5 Up arrow9  Right arrow
2 Full box6 Down arrow10 Horizontal slider
3 Info. line  7 Vertical slider
intin(4)  : Input X coordinate
intin(6)  : Input Y coordinate
intin(8)  : Input width
intin($A) : Input height
intout(0) : 0 = error
>0 = ok
intout(2) : Result X coordinate
intout(4) : Result Y coordinate
intout(6) : Result width
intout(8) : Result height
}
T:AES - wind_close
This function is used to close a window. It does not deallocate
the window or its handle, for that use wind_delete

Op: 102
intin(0)  : Window handle
intout(0) : 0 = error
>0 = ok
}
T:AES - wind_create
This function allocates a window, setting its maximum size and
returning a handle that can be used for all future operations
on this window.

Op: 100
intin(0)  : Bitmap of window components, see wind_calc
intin(2)  : X coordinate of full size window
intin(4)  : Y coordinate
intin(6)  : Width
intin(8)  : Height
intout(0) : Window handle, -ve indicates no windows available
}
T:AES - wind_delete
This function is used to delete and deallocate a window.

Op: 103
intin(0)  : Window handle
intout(0) : 0 = error
>0 = ok
}
T:AES - wind_find
This function will return the handle of the window that
is under the specified X,Y screen coordinates.

Op: 106
intin(0)  : X coordinate
intin(2)  : Y coordinate
intout(0) : Window handle

Note that if there is no window under the specified position
then the handle of the desktop window, (0), will be returned.
}
T:AES - wind_get
This function can be used to obtain a large amount of information
about a window. The complement of this function, to set window
attributes is wind_set.

Op: 104
intin(0): Window handle
intin(2): Action requested,
4 Work area"10 Top window handle
5 Current size11 1st rectangle in list
6 Previous size12 Next rectangle in list
7 Maximum size15 Horizontal slider size
8 Horizontal slider position16 Vertical slider size
9 Vertical slider position
intout(0): 0 = error
>0 = ok
intout(2-8) : Data dependent upon action requested,
4,5,6,7,11 & 12 give x coor, y coor, width and height
8,9,15 & 16give a value between 1 and 1000
10gives a window handle
}
T:AES - wind_new
This function is available on TOS 1.4 and later. It 'Closes and deletes
all windows, resets the wind_update() fnuction, flushes all the windows'
buffers and restores mouse ownership back to the system'.

Op: 109
}
T:AES - wind_open
This function is used to open and display a previously created window.

Op: 101
intin(0)  : Window handle
intin(2)  : X coordinate to open to, not necessarily full size
intin(4)  : Y coordinate
intin(6)  : Width
intin(8)  : Height
intout(0): 0 = error
>0 = ok
}
T:AES - wind_set
This function can be used to set a large number of attributes
of a window. The complement of this function, to get window
attributes is wind_get.

Op: 105
intin(0): Window handle
intin(2): Action requested,
2 Name pointer10 Top window handle
3 Information pointer14 Install new desktop
5 Current size15 Horizontal slider size
8 Horizontal slider position  16 Vertical slider size
9 Vertical slider position
intin(4-$A) : Data dependent upon action requested,
2 & 3give low word/high word of string address
5give x coor, y coor, width and height
8,9,15 & 16give a value between 1 and 1000
10gives a window handle
14give low word/high word of object tree
,pointer, and index of start object in Width
intout(0): 0 = error
>0 = ok
}
T:AES - wind_update
This function is used to prevent the user from moving a window
or pulling down a menu when a window is being updated, or if the
program is going to do its own tracking of the mouse.

Op: 107
intin(0): Action, 0 = We have finished updating a window
$1 = We are about to update a window
$2 = You can take control of the mouse back now
$3 = Please give me control of the mouse
intout(0): 0 = error
>0 = ok
}
T:AES - Resource Library
The resource library contains
functions that allow for the
loading and management of a
programs resource file.

;
L:rsrc_free:257
;
L:rsrc_gaddr:235
;
L:rsrc_load:236
;
L:rsrc_obfix:237
;
L:rsrc_saddr:238
}
T:AESrsrc_free
This function should be used once you have finished
with a resource file. It returns the memory that was
taken by the rsrc_load call.

Op: 111
intout(0) : 0 = error
>0 = ok

If you need the resource file until termination of your
program then there is no need to call this function as
all memory is deallocated in any case.
}
T:AES - rsrc_gaddr
This function is used to determine the address of an
object within a resource file previously loaded with
rsrc_load.

Op: 112
intin(0): Type of object,
0 Tree 9  Template string (tedinfo)
1 Object10 Valid chars (tedinfo)
2 Tedinfo11 Mask string (icon block)
3 Icon block12 Data string (icon block)
4 Bit block13 Text string (icon block)
5 String14 Image pointer (bit block)
6 Image data15 Address of free string
7 Obspec16 Address of free image
8 Text string (tedinfo)
intin(2): Structure index
intout(0)  : 0 = error
>0 = ok
addrout(0) : Address of the specified structure.
}
T:AES - rsrc_load
This function is used to load a resource file in to memory.

Op: 110
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of string containing resource filename
}
T:AES - rsrc_obfix
This function is used to convert the location of an object from
character coordinates to pixel coordinates.

Op: 114
intin(0)  : Index of the object to convert
intout(0) : Reserved, (=1)
addrin(0) : Address of the object tree that contains the object.
}
T:AES - rsrc_saddr
This function is used to set the address of a resource file
data structure.

Op: 113
intin(0)  : Type of structure, see rsrc_gaddr
intin(2)  : Index of the structure to be affected
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of the data structure.
}
T:AES - Shell Library
The function in the shell library
enable an application to invoke
another application and to keep
track of the calling command and
tail.

;
L:shel_envrn:239
;
L:shel_find:240
;
L:shel_get:241
;
L:shel_put:242
;
L:shel_read:243
;
L:shel_write:244
}
T:AES - shel_envrn
This function is used to search the AES environment string
for a particular variable.

Op: 125
intout(0) : Reserved, (=1)
addrin(0) : Returns pointing to the start of the variable
addrin(4) : Address of the string to search for
}
T:AES - shel_find
This function is used to search for a filename and return
the complete pathname.

Op: 124
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of 80 byte buffer that on entry contains the
filename and on exit the pathname.
}
T:AES - shel_get
This function is used to read the AES's internal shell buffer. This
is the RAM based equivalent of the DESKTOP.INF file.

Op: 122
intin(0)  : Number of bytes to read
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of buffer to read data in to

The complementary function, to write data to the AES's shell
buffer is shel_put
}
T:AES - shel_put
This function is used to write to the AES's internal shell buffer.
This is the RAM based equivalent of the DESKTOP.INF file.

Op: 123
intin(0)  : Number of bytes to write
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of buffer to write data from

The complementary function, to read data from the AES's shell
buffer is shel_get
}
T:AES - shel_read
This function can be used to determine the command line that
was used to run this program. Note that this will only work
if the program was run from the desktop.

Op: 120
intout(0) : 0 = error
>0 = ok
addrin(0) : Address of a buffer to return the command string
addrin(4) : Address of a buffer to return the command tail
}
T:AES - shel_write
This function can be used to run another program once this one
has terminated.

Op: 121
intin(0)  : 1
intin(2)  : Type of program, graphical = 1, otherwise = 0
intin(4)  : GEM application, 0 = no, 1 =yes
intout(0) : 0 = error
>0 = ok
addrin(0) : Complete pathname of application to run, with extension
addrin(4) : Address of the command tail to pass to the application
}
T:The VDI
Brief details of each of the
VDI functions are given in this
section. The required arguments
will be listed with any results
that are returned.

;
L:Workstation Control:136
;
L:Output Functions:137
;
L:Drawing Primitives:138
;
L:Attribute Functions:139
;
L:Raster Operations:140
;
L:Input Functions:141
;
L:Inquire Functions:142
;
L:Escape Functions:143
}
T:VDI - Workstation Control
The functions within this section
define the workstation parameters
and defaults. These govern the font
and window size to be used and the
generation of virtual screens.

  ;
L:v_opnwk:372
  ;
L:v_clswk:258
  ;
L:v_opnvwk:259
  ;
L:v_clsvwk:260
  ;
L:v_clrwk:261
  ;
L:v_updwk:262
  ;
L:vst_load_fonts:263
  ;
L:vst_unload_fonts:264
  ;
L:vs_clip:265
}
T:VDI - v_opnwk
This function is used to open a physical workstation. On the Atari
ST this function is only available if you have GDOS loaded. If not
use v_opnvwk.

Op: 1
Device: Returns handle to use for future calls
intin(0): Device identification number
intin(2): Line type
intin(4): Line colour
intin(6): Marker type
intin(8): Marker colour
intin($A)  : Text face
intin($C)  : Text colour
intin($E)  : Fill interior
intin($10) : Fill style
intin($12) : Fill colour
intin($14) : NDC to RC transformation flag,
0 = use Normalised Device Coorindates, 0 - 32767
1 = Reserved
2 = Use Raster Coordinate, 0 - real screen size
L:Continue:373;
. . .
}
T:VDI - v_opnwk continued
intout(0): Device width in pixels, e.g. 639 in med. and high res.
intout(2): Device height in pixels
intout(4): Device coordinate flag, 0=fine, 1=coarse
intout(6): Pixel width in microns
intout(8): Pixel height in microns
intout($A)  : Number of character heights, 0 = continuous scaling
intout($C)  : Number of linetypes
intout($E)  : Number of linewidths, 0 = continuous scaling
intout($10) : Number of marker types
intout($12) : Number of marker heights, 0 = continuouse scaling
intout($14) : Number of faces, (fonts), supported
intout($16) : Number of patterns available
intout($18) : Number of hatch styles available
intout($1A) : Number of simultaneous colours
intout($1C) : Number of Generalised Drawing Primitives, (GDPs)
intout($1E_$30) : List of 1st 10 GDPs, -1 indicates end of list
1  Bar6  Elliptical Arc
2  Arc7  Elliptical Pie
3  Pie Slice8  Rounded Rectangle
4  Circle9  Filled Rounded Rectangle
L:Continued:374;
5  Ellipse10 Justified Graphic Text
}
T:VDI - v_opnwk continued
intout($32-$44) : List of attribute set used with each GDP
0  Polyline3  Fill Area
1  Polymarker4  None
2  Text
intout($46) : Colour capability flag
intout($48) : Text rotation capability flag
intout($4A) : Fill area capability flag
intout($4C) : Cell array operation capability flag
intout($4E) : Number of colour, 0 = continuous device
intout($50) : Number of locator devices, 1 = keyboard, 2 = keyboard + other
intout($52) : Number of valuator devices, 1 = keyboard, 2 = others
intout($54) : Number of choice devices, 1 = function keys, 2 = other keypad
intout($56) : Number of string devices, 1 = keyboard
intout($58) : Workstation type,
0  Output Only2  Input/Output
1  Input Only4  Metafile Output

L:Continued:375
}
T:VDI - v_opnwk continued
ptsout(0): Minimum character width in pixels
ptsout(2): Minimum character height in pixels
ptsout(4): Maximum character width in pixels
ptsout(6): Maximum character height in pixels
ptsout(8): Minimum line width
ptsout($A)  : 0
ptsout($C)  : Maximum line width
ptsout($E)  : 0
ptsout($10) : Minimum marker width
ptsout($12) : Minimum marker height
ptsout($14) : Maximum marker width
ptsout($16) : Maximum marker height
}
T:VDI - v_clswk
This function is used to close any physical workstations opened
with the v_opnwk function. If virtual workstations have been opened
then they should be closed with v_clsvwk before calling v_clswk.

Op: 2
intin(0) : Workstation handle
}
T:VDI - v_opnvwk
This function is used to open virtual workstations. Unlike physical
workstations, virtual workstations can be opened whether you have
GDOS or not.

Op: 100
Device : On input contains address of physical workstation handle,
on return contains handle to use for future calls, see graf_handle

All other arguments are as for v_opnwk.
}
T:VDI - v_clsvwk
This function is used to close a virtual workstation previously
opened with v_opnvwk.

Op: 101
Device : Handle of workstation to close
}
T:VDI - v_clrwk
This function is used to clear the whole of a workstation previously
opened with v_opnwk or v_opnvwk. The whole screen, or page on a printer,
is set to colour 0.

Op: 3
Device : Handle of workstation

There is no need to call this after opening a physical workstation as
the VDI clears it for you. It is not recommended that you call this
after opening a virtual workstation as the whole workstation is cleared
not just your virtual workstation.
}
T:VDI - v_updwk
This fucntion has no effect on screen devices, but causes output to
printers to actually be printed.

Op: 4
Device : Handle of workstation
}
T:VDI - vst_load_fonts
This function is used to load GDOS fonts from disk.

Op: 119
Device: Workstation handle
intin(0)  : Reserved, (=0)
intout(0) : Number of fonts loaded
}
T:VDI - vst_unload_fonts
This function is used to free the memory used by GDOS fonts that have
been loaded using the vst_load_fonts call.

Op: 120
intin(0) : Reserved, (=0)

The memory will only become available once all workstations using the
fonts have been closed or used this call.
}
T:VDI - vs_clip
This function is used to set the clipping rectangle of a
specified workstation. If a clipping rectangle is installed
no drawing operation will draw anything outside this rectangle.

Op: 129
Device: Workstation handle
intin(0) : 0 = disable clipping, default when opening a workstation
1 = enable clipping
ptsin(0) : Top left X coordinate
ptsin(2) : Top left Y coordinate
ptsin(4) : Bottom right X coordinate
ptsin(6) : Bottom right Y coordinate
}
T:VDI - Output Functions
The functions within this section
draw the graphic primitives on the
specified output device.

  ;
L:v_pline:266
  ;
L:v_pmarker:267
  ;
L:v_gtext:268
  ;
L:v_fillarea:269
  ;
L:vr_recfl:270
  ;
L:v_contourfill:272
}
T:VDI - v_pline
This function is used to draw one or more lines.

Op: 6
Device: Workstation handle
ptsin(0): X coordinate of start of first line
ptsin(2): Y coordinate of start of first line
ptsin(4): X coordinate of end of first line
ptsin(6): Y coordinate of end of first line
  ...
  ...
  etc.etc.etc.

The type of line that is draw depends upon the
attributes set by vsl_color, vsl_ends, vsl_type,
vsl_udsty and vsl_width.
}
T:VDI - v_pmarker
This function is used to draw one or more marks.

Op: 6
Device: Workstation handle
ptsin(0): X coordinate of first point
ptsin(2): T coordinate of first point
  ...
  ...
  etc.etc.etc.

The type of mark that is draw depends upon the
attributes set by vsm_color, vsm_height and
vsm_type
}
T:VDI - v_gtext
This function is used to draw graphics text.

Op: 8
Device: Workstation handle
intin: The string to output in 16-bit characters
ptsin(0) : X coordinate of string position
ptsin(2) : Y coordinate of string position

The appearance of the text depends upon the text
attributes set by vst_height, vst_point, vst_rotation,
vst_font, vst_color, vst_effects and vst_alignment.

To draw justified text use the v_justified function.
}
T:VDI - v_fillarea
This function is used to draw a filled polygon.

Op: 9
Device: Workstation handle
ptsin(0) : X coordinate of first vertex
ptsin(2) : Y coordinate of first vertex
  ...
  ...
  etc.etc.etc.

It is not necessary to specify the final point
as being the same as the initial point. The function
will automatically close the polygon.

How the area is filled will depend upon the
fill attributes set by vsf_interior, vsf_style,
vsf_color, vsf_perimeter and vsf_udpat.
}
T:VDI - vr_recfl
This function is used to draw a filled rectangle.

Op: 114
Device: Workstation handle
ptsin(0)  : X coordinate of top left corner
ptsin(2)  : Y coordinate of top left corner
ptsin(4)  : X coordinate of bottom right corner
ptsin(6)  : Y coordinate of bottom right corner

A perimeter is never drawn with this function. To draw
the same rectangle with a perimeter use the v_bar function.

The appearance of the rectangle will depend upon the
fill attributes set by vsf_interior, vsf_style,
vsf_color and vsf_udpat.
}
T:VDI - v_contourfill
This function is used to 'flood' or 'seed' fill an area.

Op: 103
Device: Workstation handle
intin(0) : Colour index to stop at, if negative then fill until
a colour other than the original point is found.
ptsin(0) : X coordinate to start at
ptsin(2) : Y coordinate to start at

How the area filled is drawn depends upon the fill
area attributes set up with vsf_interior, vsf_style,
vsf_color, vsf_perimeter and vsf_udpat.
}
T:VDI - Drawing Primitives
The functions within this section define the
basic graphic primitives of rectangle, filled
and unfilled arcs and pieslices, and justified
text.

  ;
L:v_bar:273
  ;
L:v_arc:274
  ;
L:v_pieslice:275
  ;
L:v_circle:276
  ;
L:v_ellipse:277
  ;
L:v_ellarc:278
  ;
L:v_ellpie:279
  ;
L:v_rbox:280
  ;
L:v_rfbox:281
  ;
L:v_justified:282
}
T:VDI - v_bar
This function is used to draw a filled rectangle.

Op: 11
GDP: 1
Device: Workstation handle
ptsin(0)  : X coordinate of top left corner
ptsin(2)  : Y coordinate of top left corner
ptsin(4)  : X coordinate of bottom right corner
ptsin(6)  : Y coordinate of bottom right corner

A perimeter may be drawn with this function. To draw the
same rectangle without a perimeter use the vr_recfl function.

The appearance of the rectangle will depend upon the
fill attributes set by vsf_interior, vsf_style,
vsf_color, vsf_perimeter and vsf_udpat.
}
T:VDI - v_arc
This function is used to draw a circular arc.

Op: 11
GDP: 26900
Device: Workstation handle&|
intin(0)  : Start angle } 0-36001800 <-+->  0
intin(2)  : End angle}+|
ptsin(0)  : X coordinate of centre of circle2700
ptsin(2)  : Y coordinate of centre of circle
ptsin($C) : Radius of arc

The appearance of the arc will depend upon the line
attributes set by vsl_color, vsl_ends, vsl_type,
vsl_udsty and vsl_width.
}
T:VDI - v_pieslice
This function is identical to v_arc in every way, except
that the arc is filled in, giving a pie slice appearance.

Op  : 11
GDP : 3

The attributes affecting the appearance of the pie slice
are those for filled areas, vsf_interior, vsf_style,
vsf_color, vsf_perimeter and vsf_udpat.
}
T:VDI - v_circle
This function is used to draw circles.

Op: 11
GDP: 4
Device: Workstation handle
ptsin(0) : X coordinate of centre
ptsin(2) : Y coordinate of centre
ptsin(8) : Radius

The appearance of the circle depends upon the
state of the fill area attributes set by
vsf_interior, vsf_style, vsf_color, vsf_perimeter
and vsf_udpat.
}
T:VDI - v_ellipse
This function is used to draw ellipses.

Op: 11
GDP: 5
Device: Workstation handle
ptsin(0) : X coordinate of centre
ptsin(2) : Y coordinate of centre
ptsin(4) : Radius on X axis
ptsin(6) : Radius on Y axis

The appearance of the ellipse depends upon the
state of the fill area attributes set by
vsf_interior, vsf_style, vsf_color, vsf_perimeter
and vsf_udpat.
}
T:VDI - v_ellarc
This function is used to draw an elliptical arc.

Op: 11
GDP: 6
Device: Workstation handle
intin(0) : Start angle } See v_arc
intin(2) : End angle}
ptsin(0) : X coordinate of centre
ptsin(2) : Y coordinate of centre
ptsin(4) : Radius on X axis
ptsin(6) : Radius on Y axis

The appearance of the arc will depend upon the line
attributes set by vsl_color, vsl_ends, vsl_type,
vsl_udsty and vsl_width.
}
T:VDI - v_ellpie
This function is identical to v_ellarc in every way, except
that the arc is filled in, giving a pie slice appearance.

Op  : 11
GDP : 7

The attributes affecting the appearance of the pie slice
are those for filled areas, vsf_interior, vsf_style,
vsf_color, vsf_perimeter and vsf_udpat.
}
T:VDI - v_rbox
This function draws a box with rounded corners.

Op: 11
GDP: 8
Device: Workstation handle
ptsin(0)  : X coordinate of top left corner
ptsin(2)  : Y coordinate of top left corner
ptsin(4)  : X coordinate of bottom right corner
ptsin(6)  : Y coordinate of bottom right corner

The appearance of the box will depend upon the line
attributes set by vsl_color, vsl_ends, vsl_type,
vsl_udsty and vsl_width.
}
T:VDI - v_rfbox
This function draws a filled box with rounded corners.

Op: 11
GDP: 9

The other parameters are as for v_rbox

The appearance of the box will depend upon the
fill attributes set by vsf_interior, vsf_style,
vsf_color, vsf_perimeter and vsf_udpat.
}
T:VDI - v_justified
This function is used to draw justified graphical text.

Op: 11
GDP: 10
Device: Workstation handle
intin(0)  : Interword space flag} 1 = modifiy if necessary
intin(2)  : intercharacter space flag } 0 = leave alone
intin(4+) : Null terminated string in 16-bit characters
ptsin(0)  : X coordinate
ptsin(2)  : Y coordinate
ptsin(4)  : Length to fit string in to, in pixels

The appearance of the text will be dependent upon the text
attributes set by vst_height, vst_point, vst_rotation,
vst_font, vst_color, vst_effects and vst_alignment.
}
T:VDI - Attribute Functions
The functions within this section control
the appearance of the graphic primitives by
defining their size, style, colour and so on.

  ;
L:vswr_mode:283;
  ;
L:vs_color:284
  ;
L:vsl_type:285;
  ;
L:vsl_udsty:286
  ;
L:vsl_width:287;
  ;
L:vsl_color:288
  ;
L:vsl_ends:289;
  ;
L:vsm_type:290
  ;
L:vsm_height:291;
  ;
L:vsm_color:292
  ;
L:vst_height:293;
  ;
L:vst_point:294
  ;
L:vst_rotation:295;
  ;
L:vst_font:296
  ;
L:vst_color:297;
  ;
L:vst_effects:298
  ;
L:vst_alignment:299;
  ;
L:vsf_interior:300
  ;
L:vsf_style:301;
  ;
L:vsf_color:302
  ;
L:vsf_perimeter:303;
  ;
L:vsf_udpat:304
}
T:VDI - vswr_mode
This function is used to set the writing mode of all
future VDI drawing functions

Op: 32
Device: Workstation handle
intin(0) : Mode to use, 1 = replace
&2 = transparent, (mask 1s)
&3 = Ex-OR
&4 = Reverse transparent, (mask 0s)
}
T:VDI - vs_color
This function is used to redefine a colour.

Op: 14
Device: Workstation handle
intin(0) : Colour index
intin(2) : Red component}
intin(4) : Green component } Intensity 0 to 1000
intin(6) : Blue component  }
}
T:VDI - vsl_type
This sets the line attribute specifying the
type of the line.

Op: 15
Device: Workstation handle
intin(0) : Line style
1  Solid
2  Long dash
3  Dot
4  Dash dot
5  Dash
6  Dash dot dot
7  User defined, see vsl_udsty
}
T:VDI - vsl_udsty
This function is used to define the user-defined
line style.

Op: 113
Device: Workstation handle
intin(0) : Line pattern as 16 bits in the word.
}
T:VDI - vsl_width
This function is used to specify the width of all future lines. The
specified width should be an odd number or it will be rounded down.
Widened lines may not be compatible with certain other line effects.

Op: 16
Device: Workstation handle
ptsin(0)  : Line width selected
ptsout(0) : Line width set
}
T:VDI - vsl_color
This function is used to specify the colour of all future lines.

Op: 17
Device: Workstation handle
intin(0) : Colour index to use
}
T:VDI - vsl_ends
This function is used to specify the form of the ends of lines.

Op: 108
Device: Workstation handle
intin(0)  : Start style } 0 = square, (default)
intin(2)  : End style} 1 = arrow
(2 = rounded
}
T:VDI - vsm_type
This function sets the marker attribute specifying the
type of future marks.

Op: 18
Device: Workstation handle
intin(0) : Mark type
1  Dot
2  Plus
3  Asterisk
4  Square
5  Cross
6  Diamond
}
T:VDI - vsm_height
This function is used to set the size of all future marks.

Op: 19
Device: Workstation handle
ptsin(2)  : Height to use
ptsout(2) : Height actually set
}
T:VDI - vsm_color
This function is used to specify the colour of all future marks.

Op: 20
Device: Workstation handle
intin(0) : Colour index to use
}
T:VDI - vst_height
This function is used to set the height of future graphical text.
The height is specified in pixels.

Op: 12
Device: Workstation handle
ptsin(2)  : Height to use
ptsout(0) : Character width selected, pixels
ptsout(2) : Character height selected, pixels
ptsout(4) : Cell width selected, pixels
ptsout(6) : Cell height selected, pixels

In general vst_point is prefered as it allows a device independent
measuring system to be used.
}
T:VDI - vst_point
This function is used to set the height of future graphical text.
The height is specified in points, 1/72ths of an inch.

Op: 107
Device: Workstation handle
ptsin(2)  : Cell point size to use
ptsout(0) : Character width selected, pixels
ptsout(2) : Character height selected, pixels
ptsout(4) : Cell width selected, pixels
ptsout(6) : Cell height selected, pixels

vst_height can be used to set text height in terms of pixels.
}
T:VDI - vst_rotation
This function sets the angle at which future text will
be drawn.

Op: 13
Device: Workstation handle
intin(0) : Rotation to use, 0 to 3600, see v_arc for angles.

At present the ST screen drivers only support angles of 0,
900, 1800 and 2700. Do not pass a value greater than 3150 as
a bus error may occur.
}
T:VDI - vst_font
This function is used to specify which GDOS font is to be used
for future graphical text drawing. This function should only
be used with GDOS loaded.

Op: 21
Device: Workstation handle
intin(0) : Number of font to use

See vqt_name for a way to determine font numbers.
}
T:VDI - vst_color
This function is used to specify the colour of all future text.

Op: 22
Device: Workstation handle
intin(0) : Colour index to use
}
T:VDI - vst_effects
This function is used to specify which special effects will
be used when drawing graphical text.

Op: 106
Device: Workstation handle
intin(0) : Bitmap of effects to use,
Bit 0  Thicken
1  Lighten
2  Skew
3  Underline
4  Outline
5  Shadowed
}
T:VDI - vst_alignment
This function is used to determine where the values passed
as coordinates to v_gtext and v_justified actually refer.

Op: 39
Device: Workstation handle
intin(0) : Vertical alignment,
0 = Base line, bottom of characters without descenders
1 = Half line, top of lower case a's and e's
2 = Ascent line, top of upper case A's and E's
3 = Bottom, very bottom of the character cell
4 = Descent, bottom of characters with descenders
5 = Top, the very top of the character cell
intin(2) : Horizontal alignment
0 = Left justified
1 = Centre justified
2 = Right justified

Note: If a line of text is disappearing in your windows it
could very well mean that the default alignments are
putting it outside the clipping rectangle.
}
T:VDI - vsf_interior
This function specifies the fill interior style to use for
all future fills.

Op: 23
Device: Workstation handle
intin(0) : Style to use
0 = Hollow
1 = Solid
2 = Pattern
3 = Hatch
4 = User defined, see vsf_udpat
}
T:VDI - vsf_style
This function specifies the fill style to use for all future fills.

Op: 24
Device: Workstation handle
intin(0) : Dependent upon vsf_interior, 0 -> n where n is a colour
62 -> 1 to 24 patterns
63 -> 1 to 12 hatches
}
T:VDI - vsf_color
This function is used to specify the colour of all future fills.

Op: 25
Device: Workstation handle
intin(0) : Colour index to use
}
T:VDI - vsf_perimeter
This function is used to specify whether future fills will be
accompanied by a perimeter or not.

Op: 104
Device: Workstation handle
intin(0) : Flag, 0 = invisible perimeter
1 = visiable perimeter
}
T:VDI - vsf_udpat
This function allows you to specify the user defined fill style.

Op: 112
Device: Workstation handle
intin(0-15)  : Contents of first plane
intin(16-31) : Contents of second plane
...
...
etc.etc.etc.
}
T:VDI - Raster Operations
The raster operation functions are concerned with the manipulation of
rectangular blocks of bits in memory or pixels on screen. These blocks
are defined using a Memory Form Definition Block.

 $0  Memory pointer
 $4  Width in pixels
 $6  Height in pixels
 $8  Width in words
 $A  Format flag, 1 = standard, 0 = device specific
 $C  Number of planes in raster area
 $E  3 reserved words

;
L:vro_cpyfm:305
;
L:vrt_cpyfm:306
;
L:vr_trnfm:307
;
L:v_get_pixel:308
}
T:VDI - vro_cpyfm
This function is used to copy rectangular blocks of memory. These
can be copied to or from memory or the screen.

Op: 109
Device: Workstation handle
intin(0): Logical operation to perform
ptsin(0): X1 coordinate of source block, lower left
ptsin(2): Y1 coordinate of source block
ptsin(4): X2 coordinate of source block, upper right
ptsin(6): Y2 coordinate of source block
ptsin(8): X1 coordinate of destination block, lower left
ptsin($A)  : Y1 coordinate of destination block
ptsin($C)  : X2 coordinate of destination block, upper right
ptsin($E)  : Y2 coordinate of destination block
cntrl($E)  : Address of source MFDB
cntrl($12) : Address of destination MFDB
}
T:VDI - vrt_cpyfm
This function is used to convert a monochrome image to a colour image.

Op: 121
Device: Workstation handle
intin(0): Write mode, as for vswr_mode
intin(2): Colour index for set bits
intin(4): Colour index for clear bits
ptsin(0): X1 coordinate of source block, lower left
ptsin(2): Y1 coordinate of source block
ptsin(4): X2 coordinate of source block, upper right
ptsin(6): Y2 coordinate of source block
ptsin(8): X1 coordinate of destination block, lower left
ptsin($A)  : Y1 coordinate of destination block
ptsin($C)  : X2 coordinate of destination block, upper right
ptsin($E)  : Y2 coordinate of destination block
cntrl($E)  : Address of source MFDB
cntrl($12) : Address of destination MFDB
}
T:VDI - vr_trnfm
This function is used to convert a standard MFDB to a device
specific MFDB or vice versa.

Op: 110
Device: Workstation handle
cntrl($E)  : Address of source MFDB
cntrl($12) : Address of destination MFDB
}
T:VDI - v_get_pixel
This function is used to determine the colour value of a specified
pixel.

Op: 105
Device: Workstation handle
intin(0)  : X coordinate
intin(2)  : Y coordinate
intout(0) : Pixel value
intout(2) : Colour index
}
T:VDI - Input Functions
The functions within this section provide
the programmer with simple 'request and
wait' and 'request and sample' input functions.

If the AES is being used, these functions
should be avoided.

  ;
L:vsc_form:309
  ;
L:vex_timv:310
  ;
L:v_show_c:311
  ;
L:v_hide_c:312
  ;
L:vq_mouse:313
  ;
L:vex_butv:314
  ;
L:vex_motv:315
  ;
L:vex_curv:316
  ;
L:vq_key_s:317
  ;
L:vsin_mode:318
  ;
L:vrq_locator:319
  ;
L:vsm_locator:320
  ;
L:vrq_string:325
  ;
L:vsm_string:326
}
T:VDI - vsc_form
This function is used to change the appearance of the mouse
cursor to some user defined shape. If you are using the AES
in your program then you should use the graf_mouse function.

Op: 111
Device: Workstation handle
intin(0): X coordinate of hot spot
intin(2): Y coordinate of hot spot
intin(4): Reserved, (=1)
intin(6): Mask colour, usually 0
intin(8): Data colour, usually 1
intin($A-$28)  : 16 x word sized mask bits
intin($2A-$48) : 16 x word sized data bits
}
T:VDI - vex_timv
This function is used to add a routine that will be executed
with every system timer tick. Currently these happen 50 times
a second.

Op: 118
Device: Workstation handle
cntrl($E)  : Address of new routine
cntrl($12) : On return contains address of old routine
intout(0)  : Milliseconds per tick

The routine that you install should call the old routine.

You should not call Gemdos, AES or VDI routines in your routine and should
avoid calling;
L:Bios:5;
and Xbios routines as the operating system is not
very re-entrant. Your routine should preserve all registers.

You should make sure that when your program terminates it
removes the timer routine that you have installed or it
will continue to execute!!
}
T:VDI - v_show_c
This function complements the v_hide_c call and is used to
display the mouse cursor. If you use the AES in your program
then use graf_mouse instead.

Op: 122
Device: Workstation handle
intin(0) : 0 = show the mouse cursor
n = only show the cursor if v_show_c has been called
more often than v_hide_c
}
T:VDI - v_hide_c
This function is used to hide the mouse cursor. If you use the
AES in your program then use graf_mouse instead.

Op: 123
Device : Workstation handle

See the v_show_c function for how to show the cursor again.
}
T:VDI - vq_mouse
This function is used to sample the current mouse position
and button state.

Op: 124
Device: Workstation handle
ptsout(0) : X coordinate
ptsout(2) : Y coordinate
intout(0) : Bitmap of button state, 0 = up, 1 = down
.bit 0 = left 1 = right
}
T:VDI - vex_butv
This function can be used to install a routine that is
called every time the mouse button state changes.

Op: 125
Device: Workstation handle
cntrl($E)  : Address of new routine
cntrl($12) : On return contains address of old routine

The same rules as laid down for vex_timv should be followed as
far as the operating system is concerned. Obviously your routine
does not need to call the old one.

The button state, in the same format as vq_mouse, is passed in
register D0.W, and can be changed by your routine.
}
T:VDI - vex_motv
This function can be used to install a routine that is
called every time the mouse is moved.

Op: 126
Device: Workstation handle
cntrl($E)  : Address of new routine
cntrl($12) : On return contains address of old routine

The same rules as laid down for vex_timv should be followed as
far as the operating system is concerned. Obviously your routine
does not need to call the old one.

The X and Y coordinates of the mouse cursor are passed in
registers D0.W and D1.W, your routine may of course change these.
}
T:VDI - vex_curv
This function can be used to install a routine that is
called every time the mouse is redrawn.

Op: 127
Device: Workstation handle
cntrl($E)  : Address of new routine
cntrl($12) : On return contains address of old routine

The same rules as laid down for vex_timv should be followed as
far as the operating system is concerned. Obviously your routine
does not need to call the old one.

The X and Y coordinates of the mouse cursor are passed in
registers D0.W and D1.W.
}
T:VDI - vq_key_s
This function is used to sample the current state of the
shift keys.

Op: 128
Device: Workstation handle
intout(0) : Bitmap of keys, 0 = right shift key1 = down
*1 = left shift key0 = up
*2 = control
*3 = alternate
}
T:VDI - vsin_mode
This function is used to set whether a VDI input device is
to use request or sample mode. If you are using the AES at
all then do not change modes as it will become quite confused.

Op: 33
Device: Workstation handle
intin(0)  : Input device, 1 = locator, 2 = valuator
(3 = choice , 4 = string
intin(2)  : Input mode, 1 = request, 2 = sample
intout(0) : Mode actually selected
}
T:VDI - vrq_locator
This function tracks the mouse in request mode until a
mouse or keyboard event occurs. If you are using the AES
then do not use VDI input routines.

Op: 28
Device: Workstation handle
ptsin(0): Initial X coordinate
ptsin(2): Initial Y coordinate
ptsout(0)  : Final X coordinate
ptsout(2)  : Final Y coordinate
intout(0)  : Terminating character, 32 = left button
233 = right button
/other = ASCII key value
}
T:VDI - vsm_locator
This function is similar to vrq_locator but instead of waiting
for a mouse button or key press the states are sampled and the
routine returns immediately. If you are using the AES then you
should avoid using VDI input routines.

Op: 28
Device: Workstation handle
ptsin(0): Initial X coordinate
ptsin(2): Initial Y coordinate
ptsout(0)  : Final X coordinate } Only if the mouse moved
ptsout(2)  : Final Y coordinate }
intout(0)  : Terminating character, 32 = left button} Only if button
233 = right button} or key was
/other = ASCII key value } pressed
}
T:VDI - vrq_string
This function is used to wait for input from the keyboard.
If you are using the AES then do not use VDI input routines.

Op: 31
ptsin(0)  : Screen X coordinate } Not implemented on the ST, but must
ptsin(2)  : Screen Y coordinate } be pointed somewhere to avoid bombs
intin(0)  : Maximum string length, including null termination
intin(2)  : 0 = no echo
1 = echo at ptsin, Echo is not implemented on the ST
intout(0) : Length of string input.
}
T:VDI - vsm_string
This function is identical to vrq_string except that if no
characters are available the routine returns immediately.

Arguments as for vrq_string
cntrl(8) : 0 = No characters available
}
T:VDI - Inquire Function
These functions allow the programmer
to determine the capabilities and
functions supported by a particular
graphical device.

  ;
L:vq_extnd:327
  ;
L:vq_color:328
  ;
L:vql_attributes:329
  ;
L:vqm_attributes:330
  ;
L:vqf_attributes:331
  ;
L:vqt_attributes:332
  ;
L:vqt_extent:333
  ;
L:vqt_width:334
  ;
L:vqt_name:335
  ;
L:vqin_mode:337
  ;
L:vqt_fontinfo:338
}
T:VDI - vq_extnd
This function can be used to return the same information as
v_opnwk, or even more.

Op: 102
Device: Workstation handle
intin(0): Flag, 0 = v_opnwk values, 1 = extended information
intout(0): Type of screen, 0 = not screen, 4 = 'normal' screen
intout(2): Number of background colours available
intout(4): Bitmap of text effects supported, see vst_effects
intout(6): Support for raster scaling, 0 = no, 1 = yes
intout(8): Number of planes
intout($A)  : Look up table support, 1 = no, 0 = yes
intout($C)  : Speed factor, number of 16x16 raster operations per second
intout($E)  : Contour fill capability, 0 = no, 1 = yes
intout($10) : Character rotation, 0 = no, 1 = 90 degree intervals, 2 = yes
intout($12) : Number of writing modes available
intout($14) : Input mode, 0 = none, 1 = request, 2 = sample
intout($16) : Text alignment, 0 = no, 1 = yes
intout($18) : Inking ability, 0 = no, 1 = yes

L:Continued:376;
. . .
}
T:VDI - vq_extnd Continued
intout($1A) : Rubberbanding, 0 = no, 1 = lines, 2 = lines & rectangles
intout($1C) : Maximum number of points for polylines etc. -1 = no maximum
intout($1E) : Maximum index for intin, -1 = no maximum
intout($20) : Number of keys on mouse
intout($22) : Styles for wide lines, 0 = no, 1 = yes
intout($24) : Writing modes for wide lines, 0 = no, 1 = yes
intout($26-$58) : Reserved
ptsout(0-$16): Reserved
}
T:VDI - vq_color
This function is used to return the RGB information for a
specified colour in the palette.

Op: 26
Device: Workstation handle
intin(0): Colour index
intin(1): Flag, 0 = return colour as requested
!1 = return colour as it appears on device
intout(0)  : Colour index, -1 = out of range
intout(2)  : Red intensity}
intout(4)  : Green intensity } 0 to 1000
intout(6)  : Blue intensity  }
}
T:VDI - vql_attributes
This function returns the current line attributes.

Op: 35
Device: Workstation handle
ptsout(0) : Line width, see vsl_width
intout(0) : Line type, see vsl_type and vsl_udsty
intout(2) : Line colour, see vsl_color
intout(4) : Write mode, see vswr_mode
intout(6) : Start end style, see vsl_ends
intout(8) : Finish end style
}
T:VDI - vqm_attributes
This function returns the current marker attributes.

Op: 36
Device: Workstation handle
ptsout(0) : Marker width, see vsm_height
ptsout(2) : Marker height
intout(0) : Marker type, see vsm_type
intout(2) : Marker colour, see vsm_color
intout(4) : Write mode, see vswr_mode
}
T:VDI - vqf_attributes
This function returns the current fill area attributes.

Op: 37
Device: Workstation handle
intout(0) : Interior style, see vsf_interior
intout(2) : Colour, see vsf_color
intout(4) : Fill style, see vsf_style
intout(6) : Write mode, see vswr_mode
intout(8) : Perimeter flag, see vsf_perimeter
}
T:VDI - vqt_attributes
This function returns the current graphical text attributes.

Op: 38
Device: Workstation handle
ptsout(0)  : Character width, see vst_height, vst_point
ptsout(2)  : Character height
ptsout(4)  : Character cell width
ptsout(6)  : Character cell height
intout(0)  : Font number, see vst_font
intout(2)  : Colour, see vst_color
intout(4)  : Angle of rotation, see vst_rotation
intout(6)  : Horizontal alignment, see vst_alignment
intout(8)  : Vertical alignment, see vst_alignment
intout($A) : Write mode, see vswr_mode
}
T:VDI - vqt_extent
This function returns the screen area that will enclose a
specified string. This area takes in to account any special
text effects that may in force.

Op: 116
Device: Workstation handle
intin: Contains the string in 16-bit characters
ptsout(0)  : X coordinate bottom left
ptsout(2)  : Y coordinate bottom left
ptsout(4)  : X coordinate bottom right
ptsout(6)  : Y coordinate bottom right
ptsout(8)  : X coordinate top right
ptsout($A) : Y coordinate top right
ptsout($C) : X coordinate top left
ptsout($E) : Y coordinate top left
}
T:VDI - vqt_width
This function returns the width of a cell completely enclosing
the specified character.

Op: 117
Device: Workstation handle
intin(0): Character to measure
ptsout(0)  : Cell width
ptsout(4)  : White space to the left
ptsout(8)  : White space to the right
intout(0)  : intin(0) if ok
-1 if illegal character
}
T:VDI - vqt_name
This function returns the name and index of a font given a font
number. This is used when changing the current font using vst_font.

Op: 130
Device: Workstation handle
intin(0)  : Font number
intout(0) : Font number
intout(2-$40) : Font name in 16-bit characters
}
T:VDI - vqin_mode
This function returns the current mode for a given VDI
input device.

Op: 115
Device: Workstation handle
intin(0)  : Logical device, 1 = locator, 2 = valuator
*3 = choice,  4 = string
intout(0) : Input mode, 1 = request
&2 = sample
}
T:VDI - vqt_fontinfo
This function returns information about the current font.

Op: 131
Device: Workstation handle
ptsout(0): Maximum normal cell width
ptsout(2): Baseline to bottom
ptsout(4): Maximum extra skew width
ptsout(6): Baseline to descent line
ptsout(8): Left skew extra
ptsout($A)  : Baseline to half distance
ptsout($C)  : Right skew extra
ptsout($E)  : Baseline to ascent
ptsout($12) : Baseline to top distance
intout(0): First character in the font
intout(2): Last character in the font
}
T:VDI - Escape Functions
The functions within this section
allow an application to access the
special features of a certain
graphical device.

  ;
L:vq_chcells:339;
  ;
L:v_exit_cur:340
  ;
L:v_enter_cur:341;
  ;
L:v_curup:342
  ;
L:v_curdown:343;
  ;
L:v_curright:344
  ;
L:v_curleft:345;
  ;
L:v_curhome:346
  ;
L:v_eeos:347;
  ;
L:v_eeol:348
  ;
L:vs_curaddress:349;
  ;
L:v_curtext:350
  ;
L:v_rvon:351;
  ;
L:v_rvoff:352
  ;
L:vq_curaddress:353;
  ;
L:vq_tabstatus:354
  ;
L:v_hardcopy:355;
  ;
L:v_dspcur:356
  ;
L:v_rmcur:357;
  ;
L:v_form_adv:358
  ;
L:v_output_window:359;
  ;
L:v_clear_disp_list:360
  ;
L:v_bit_image:361;
  ;
L:v_meta_extents:369
  ;
L:v_write_meta:370;
  ;
L:vm_filename:371
}
T:VDI - vq_chcells
This function is used to determine
the number of rows and columns on
the TOS type screen.

Op: 5
GDP: 1
Device: Workstation handle
intout(0) : Number of rows
intout(2) : Number of columns
}
T:VDI - v_exit_cur
This function is used to exit alpha mode. See v_enter_cur
for details of entering alpha mode. The function turns off
the TOS cursor and turns on the mouse cursor. However it
does not force a screen redraw.

Op: 5
GDP: 2
Device : Workstation handle
}
T:VDI - v_enter_cur
This function is used to enter alpha mode. See v_exit_cur
for details of leaving alpha mode. The function turns off
the mouse cursor, turns on the TOS cursor and clears the
screen.

Op: 5
GDP: 3
Device : Workstation handle
}
T:VDI - v_curup
This function is used to move the alpha cursor up one line.
If it is on the top line then it will stay there.

Op: 5
GDP: 4
Device : Workstation handle
}
T:VDI - v_curdown
This function is used to move the alpha cursor down one line.
If it is on the bottom line then it will stay there.

Op: 5
GDP: 5
Device : Workstation handle
}
T:VDI - v_curright
This function is used to move the alpha cursor one column to
the right. If it is in the last column then it will stay there.

Op: 5
GDP: 6
Device : Workstation handle
}
T:VDI - v_curleft
This function is used to move the alpha cursor one column to
the left. If it is in the first column then it will stay there.

Op: 5
GDP: 7
Device : Workstation handle
}
T:VDI - v_curhome
This function is used to move the alpha cursor to the home
position. This is the top left of the screen.

Op: 5
GDP: 8
Device : Workstation handle
}
T:VDI - v_eeos
This function is used to clear the alpha screen from the
current cursor position to the end of the screen. The
position of the cursor does not change.

Op: 5
GDP: 9
Device : Workstation handle
}
T:VDI - v_eeol
This function is used to clear the alpha screen from the
current cursor position to the end of the current line.
The position of the cursor does not change.

Op: 5
GDP: 10
Device : Workstation handle
}
T:VDI - vs_curaddress
This function is used to move the alpha cursor to the specified
position on the screen.

Op: 5
GDP: 11
Device: Workstation handle
intin(0) : row, 1 to n
intin(2) : column, 1 to n
}
T:VDI - v_curtext
This function is used to display a string on the alpha screen
at the current cursor position.

Op: 5
GDP: 12
Device : Workstation handle
intin  : String in 16-bit characters
}
T:VDI - v_rvon
This function is used to turn reverse video on for
future alpha text.

Op: 5
GDP: 13
Device : Workstation handle
}
T:VDI - v_rvoff
This function is used to turn reverse video off for
future alpha text.

Op: 5
GDP: 14
Device : Workstation handle
}
T:VDI - vq_curaddress
This function is used to determine the alpha cursor
position on the screen.

Op: 5
GDP: 15
Device: Workstation handle
intout(0) : row, 1 to n
intout(2) : column, 1 to n
}
T:VDI - vq_tabstatus
This function returns a value indicating whether there
is a graphics tablet available or not.

Op: 5
GDP: 16
Device: Workstation handle
intout(0) : Availability, 0 = none
(1 = available
}
T:VDI - v_hardcopy
Ths function dumps the screen to the printer in the same way
as the Alternate+Help key combination and Scrdmp operating
system call.

Op: 5
GDP: 16
Device : Screen workstation handle
}
T:VDI - v_dspcur
This function displays the mouse cursor at the specified
screen position.

Op: 5
GDP: 18
Device: Workstation handle
ptsin(0) : X coordinate
ptsin(2) : Y coordinate

If you are using the AES then you should use graf_mouse instead.
If you are not using the AES then you should use v_show_c instead.
}
T:VDI - v_rmcur
This function removes the mouse cursor from the screen.

Op: 5
GDP: 19
Device: Workstation handle

If you are using the AES then you should use graf_mouse instead.
If you are not using the AES then you should use v_show_c instead.
}
T:VDI - v_form_adv
This function is only available under GDOS and will advance
the printer to the top of the next page.

Op: 5
GDP: 20
Device: Workstation handle
}
T:VDI - v_output_window
This function is only available under GDOS and will print only
a specified rectangle of the currently formed page.

Op: 5
GDP: 21
Device: Workstation handle
ptsin(0) : X coordinate top left corner
ptsin(2) : Y coordinate top left corner
ptsin(4) : X coordinate bottom right corner
ptsin(6) : Y coordinate bottom right corner
}
T:VDI - v_clear_disp_list
This function is only available under GDOS and clear the printer
display list without sending a form feed.

Op: 5
GDP: 22
Device: Workstation handle
}
T:VDI - v_bit_image
This function is only available under GDOS and allows
you to print a .IMG file straight from the disk to the
printer!

Op: 5
GDP: 23
Device: Workstation handle
cntrl(2)  : Flag, 0 = get coordinate from file
 1 = upper left specified
ptsin(0)  : X coordinate of top left
ptsin(2)  : Y coordinate of top left
ptsin(4)  : X coordinate of bottom right
ptsin(6)  : Y coordinate of bottom right
intin(0)  : Aspect ratio flag, 0=ignore, 1=pixel ratio, 2=page ratio
intin(2)  : Scaling, 0 = uniform, 1 = X and Y
intin(4+) : Filename in 16-bit characters
}
T:VDI - v_meta_extents
This function is used to set the extent rectangle in a
metafile header.

Op: 5
GDP: 98
Device: Workstation handle
ptsin(0) : Minimum X
ptsin(2) : Minimum Y
ptsin(4) : Maximum X
ptsin(6) : Maximum Y
}
T:VDI - v_write_meta
This function is used to write items to a metafile.

Op: 5
GDP: 99
Device: Metafile workstation handle
intin(0) : Sub-Opcode, 10  Start group
%11  End group
%49  Set no line style
%50  Set attribute shadow on
%51  Set attribute shadow off
%80  Start draw area type primitive
%81  End draw arear type primitive
}
T:VDI - vm_filename
This function is used to change the filename of a metafile.

Op: 5
GDP: 100
Device : Metafile workstation handle
intin  : Path and filename to use in 16-bit characters
}
T:The Line-A
Machine code instructions starting $Axxx
are illegal instructions on the MC68000,
however they are routed through a special
exception vector. On the Atari ST this
is used to implement very low-level drawing
operations.

 ;
L:Initialise:144
 ;
L:Plot pixel:145;
;
L:Get pixel:146
 ;
L:Draw line:147;
;
L:Draw horizontal line:148
 ;
L:Draw rectangle:149;
  ;
L:Draw polygon:150
 ;
L:BITBLiT:151;
;
L:Draw character:152
 ;
L:Show mouse:153;
;
L:Hide mouse:154
 ;
L:Transform mouse:155
 ;
L:Remove a sprite:156;
 ;
L:Draw a sprite:157
 ;
L:Copy raster form:158
 ;
L:Flood fill:159

 ;
L:Line-A variables:160
}
T:Line-A - Initialise
This function is used to initialise the Line-A data structures.

Op code : $A000

The function returns,
D0 = base address of Line-A variables
A0 = base address of Line-A variables
A1 = address of pointers to fonts
A2 = address of 15 pointers to the 15 Line-A routines

This function trashes at least D0-D2 and A0-A2.
}
T:Line-A - Plot Pixel
This function is used to plot single pixels.
No clipping rectangle is used.

Op code  : $A001
ptsin(0) : X coordinate
ptsin(2) : Y coordinate
intin(0) : Colour index
}
T:Line-A - Get Pixel
This function is used to determien the colour of a
pixel on the screen. No clipping rectangle is used.

Op code  : $A002
ptsin(0) : X coordinate
ptsin(2) : Y coordinate

The colour index is returned in register D0
}
T:Line-A - Draw Line
This function is used to draw an arbitrary line between
two points. No clipping rectangle is used.

Op: $A003
X1: X coorindate of one end of the line
Y1: Y coordinate of the same end of the line
X2: X coorindate of the other end of the line
Y2: Y coordinate of this end
COLBIT0 : Colour to use
COLBIT1 : Colour value shifted one place to the right
COLBIT2 : Colour value shifted two places to the right
COLBIT3 : Colour value shifted three places to the right
LNMASK  : Line style mask
WRTMOD  : Writing mode, 0 = Replace, 1 = Transparent
&2 = Ex-OR,3 = Reverse transparent
LSTLIN  : Draw last pixel flag, -1 = omit point
/0 = draw point
}
T:Line-A - Draw Horizontal Line
This function is used to draw horizontal lines.
No clipping rectangle is used.

Op*: $A004
X1, Y1, X2, COLBIT0-3, WRTMOD : See Draw Line
PATPTR&: Address of array of word size line styles
PATMASK%: Number of line styles at PATPTR
MFILL': If non-zero then ignore WRT_MOD
}
T:Line-A - Draw Rectangle
This function is used to draw filled rectangles.
An optional clipping rectangle can be used.

Op#: $A005
X1#: Left X coordinate
Y1#: Top Y coordinate
X2#: Right X coordinate
Y2#: Bottom Y coordinate
COLBIT0-3, WRTMOD: See Draw Line
PATPTR, PATMASK, MFILL : See Draw Horizontal Line
CLIP!: Cliiping flag, 1 = enable clipping,
60 = disable clipping
XMNCLIP: X minimum for clipping
XMXCLIP: X maximum for clipping
YMNCLIP: Y minimum for clipping
YMXCLIP: Y maximum for clipping
}
T:Line-A - Draw Polygon
This function is used to draw a line in a filled
polygon. An optional clipping rectangle can be used.

Op#: $A006
ptsin : X,Y array of polygon vertices
contrl(2): Number of vertices
Y1#: Line to draw
COLBIT0-3, WRTMOD: See Draw Line
PATPTR, PATMASK, MFILL : See Draw Horizontal Line
CLIP, ?M?CLIP: See Draw Rectangle
}
T:Line-A - BITBLiT
This function is the system primitive block transfer function.

Op: $A007

The register A6 should be loaded with the address of a parameter
table formed as follows . . .

 0  b_width  Width of block in pixels
 2  b_height Height of block in pixels
 4  planesNumber of consecutive planes to bit
 6  fg_colForeground colour
 8  bg_colBackground colour
$A  op_table }
$B} Table of 4 raster op code bytes, each containing
$C} one of sizteen logical operations (?)
$D}
$E  s_xminMinimum source X
$10 s_yminMinimum source Y
$12 s_formSource form base address

L:Continued:205;
. . .
}
T:Line-A - BITBLiT Continued
$16 s_nxwdWord in line  } next offset(2=hi,4=med,8=low)
$18 s_nxlnLine in plane } in bytes, (80=hi,160=med/low)
$1A s_nxplNext plane offset from current, always 2
$1C d_xminMinimum destination X
$1D d_yminMinimum destination Y
$20 d_formDestination form base address
$24 d_nxwdWord in line  } next offset(2=hi,4=med,8=low)
$26 d_nxlnLine in plane } in bytes, (80=hi,160=med/low)
$28 d_nxplNext plane offset from current, always 2
$2A p_addrAddress of pattern buffer, ANDed before blitting, 0 = none
$2D p_nxlnNext line in pattern  } offset (2, 4, 6 etc.)
$30 p_nxplNext plane in pattern } in bytes (0 = 1 plane)
$32 p_maskPattern index mask length
}
T:Line-A - Draw Character
This function is used for drawing bit-mapped fonts on the screen.

Op: $A008
WRTMOD: See Draw Line
TEXTFG/TEXTBG : Foreground/Background colour
FBASE/FWIDTH  : Base/width of font form
SOURCEX: X coordinate of character in font form
SOURCEY: Y coordinate of character in font form = 0
DESTX/DESTY: Screen coordinate to plot character at
DELX/DELY: Width/Height of character
STYLE: Style flags, see vst_effects
LITEMASK: Lightening text mask
SKEWMASK: Skewing text mask
WEIGHT: Thickening width
ROFF/LOFF: Skewing offset above/below baseline

L:Continued:210;
. . .
}
T:Line-A - Draw Character Continued
SCALE: Scaling flag, 0 = none
XACCDDA: Scaling variable = $8000
DDAINC: Scaling factor, going up = $100 * (final - actual)/actual
,going down = $100 * final / actual
TSCLSTS: Scaling direction, 0 = down, non-zero = up
CHUP: Rotation angle, see vst_rotation
MONOFLAG: Monospaced = 1, otherwise proportional
scrtchp: Address of scratch buffer, 2 * size of largest character
scrpt2: Offset in to scrtchp for use when enlarging characters

A clipping rectangle can be used for this function, see Draw Rectangle
}
T:Line-A - Show Mouse
This function is used to display the mouse cursor if the number
of calls to this function is greater than or equal to the number
of calls to the hide mouse function.

Op: $A009
intin(0) : If 0 display mouse regardless of number of calls, see v_show_c
}
T:Line-A - Hide Mouse
This function is used to hide the mouse cursor and is identical
to v_hide_c.

Op : $A00A
}
T:Line-A - Transform Mouse
This function is used to change the appearance of the mouse in
a similar way to vsc_form.

Op: $A00B
intin(0): X hot spot
intin(2): Y hot spot
intin(4): Draw type, 1 = VDI, -1 = Ex-OR
intin(6): Background colour index
intin(8): Foreground colour index
intin($A+) : 32 words, 0 = First line of image
%1 = First line of mask
%2 = Second line of image
%3 = Second line of mask
&...
%etc.etc.etc.
}
T:Line-A - Remove Sprite
This function is used to undraw a previously drawn sprite.

Op :$A00C

Register A2 is passed as a pointer the sprite
save block used when drawing the sprite.
}
T:Line-A - Draw Sprite
This function is used to draw a sprite.

Op : $A00D

Register D0 specifies the sprite X position

Register D1 specifies the sprite Y position

Register A0 is the address of a sprite definition block defined
in the same way as intin(0+) in the transform mouse call.

Register A2 is the address of a block of memory to use to save
the screen under the sprite. This must be at least
10 + (64 * number of planes) bytes big.
}
T:Line-A - Copy Raster
This function is a combination of vro_cpyfm and vrt_cpyfm.

Op: $A00E
intin(0): Logical operation to perform
intin(2): Colour to use for 1's in data
intin(4): Colour to use for 0's in data
contrl($E)  : Address of source MFDB
contrl($12) : Address of destination MFDB
ptsin(0): X coordinate of lower left of first rectangle
ptsin(2): Y coordinate of lower left of first rectangle
ptsin(4): X coordinate of upper right of first rectangle
ptsin(6): Y coordinate of upper right of first rectangle
ptsin(8): X coordinate of lower left of second rectangle
ptsin($A): Y coordinate of lower left of second rectangle
ptsin($C): X coordinate of upper right of second rectangle
ptsin($E): Y coordinate of upper right of second rectangle
COPYTRAN: Opaque, (=0) or transparent, (=1), copy

A clipping rectangle can be used for this function, see Draw Rectangle
}
T:Line-A - Flood Fill
This function is used to flood fill an area in a similar way to
the VDI function v_contourfill.

Op : $A00F
intin(0) : Colour, see v_contourfill
ptsin(0) : X coordinate of start point
ptsin(2) : Y coordinate of start point
WRTMOD: See Draw Line
PATPTR, PATMASK, MFILL : See Draw Horizontal Line
SEEDABORT: Address of a function to call at the end of every
'line. If this function returns 0 the fill continues.
CLIP, ?M?CLIP: See Draw Rectangle

A clipping rectangle is always used regardless of the value of CLIP.

This function takes the fill colour from the VDI vsf_color value.
Thus a workstation must be open when calling this function.
}
T:Line-A - Variables
$00Number of video planes
$02Number of bytes per video line
$04Address of cntrl array
$08Address of intin array
$0CAddress of ptsin array
$10Address of intout array
$14Address of ptsout array
$18  COLBIT0 Bit plane 0 }
$1A  COLBIT1 Bit plane 1 } Current colour value
$1C  COLBIT2 Bit plane 2 }
$1E  COLBIT3 Bit plane 3 }
$20  -1
$22  LNMASK  VDI line style equivalent
$24  WRTMOD  Writing mode, 0 = Replace, 1 = Transparent,
)2 = Ex-OR,3 = Reverse transparent
$26  X1X1 coordinate
$28  Y1Y1 coordinate
$2A  X2X2 coordinate
$2C  Y2Y2 coordinate

L:Continued:161;
. . .
}
T:Line-A - Variables Continued
$2E  PATPTR  Address of fill pattern table
$32  PATMASK Fill pattern mask, (length of pattern)
$34Multi-plane fill pattern, 0=single plane, 1=multi-plane
$36  CLIPClipping flag, 0=no clipping
$38  XMNCLIP Minimum X clipping value
$3A  YMNCLIP Minimum Y clipping value
$3C  XMXCLIP Maximum X clipping value
$3E  YMXCLIP Maximum Y clipping value
$40  XACCDDA Accumulator for textblt = $8000
$42  DDAINC  Textblt scaling factor
$44  TSCLSTS Scaling direction, 0=down
$46Font status, 1=may be thickened
$48  SOURCEX X coordinate of character in font form
$4A  SOURCEY Y coordinate of character in font form = 0
$4C  DESTXX coordinate of character on screen
$4E  DESTYY coordinate of character on screen
$50  DELXCharacter width
$52  DELYCharacter height
$54  FBASEPointer to start of font data

L:Continued:271;
. . .
}
T:Line-A - Variables Continued
$58  FWIDTHWidth of font form
$5A  STYLEText effects, see txt_effects
$5C  LITEMASK  Lightening text mask
$5E  SKEWMASK  Skewing text mask
$60  WEIGHTText thickening additional width
$62  ROFFOffset above character baseline for skew
$64  LOFFOffset below character baseline for skew
$66Scaling factor
$68  CHUPCharacter rotation vector
$6A  TEXTFGText foreground colour
$6C  scrtchpAddress of special effects buffer
$70  scrpt2Scaling buffer offset in scrtchp
$72  TEXTBGText background colour
$74  COPYTRAN  Copy raster form type flag, 0=opaque, 1=transparent
$76  SEEDABORT Address of function to call after every line on a seed fill
}
T:The MC68000
This section covers the MC68000
processor at the heart of the
Atari ST.

;
L:The Registers:162
;
L:Addressing Modes:163
;
L:Instructions:164
;
L:Timings:165
}
T:MC68000 - Registers
D0 }0A0 }
D1 }0A1 }  7 x 32 bit general purpose
D2 }  8 x 32 bit general purposeA2 }  address registers, Addressable
D3 }  data registers. AddressableA3 }  byword, bits 0-15
D4 }  bybyte, bits 0-7A4 }  or longword, bits 0-31
D5 }word, bits 0-15A5 }
D6 }  or longword, bits 0-31A6 }
D7 }

A7  Address register used specifically
for the user and supervisor stacks.

PC  Program counter, 32 bits

SR  Status register, 16 bits, made up asT.S..III...XNZVC

T= Trace bitX = Extend bit}
S= Supervisor bitN = Negative bit  }
III = Interrupt bit fieldZ = Zero bit} The condition codes.
0V = Overflow bit  }
0C = Carry bit}
}
T:MC68000 - Addressing modes
Data Register Direct : This addressing mode implies the use of the
contents of any of the 8 general purpose Data regsiters.

Effective Address, (EA), = Dn(n = 0-7)

Address Register Direct : This addressing mode implies the use of the
contents of any of the 7 general purpose Address registers,
or A7 the stack pointer.

EA = An

Address Register Indirect : This addressing mode implies the use of the
byte, word or longword pointed to by the contents of any of
the address registers.

EA = (An)

L:Continued:321;
. . .
}
T:MC68000 - Addressing modes Continued
Address Register Indirect with Postincrement : This addressing mode is
identical to the;
L:above mode,:163;
except that upon completion the
address register is incremented by the size of the operand,
(byte=1,word=2,longword=4) If the stack pointer is used the
increment is always by at least 2.

EA = (An)+

Address Register Indirect with Predecrement : This addressing mode is
identical the to;
L:Address Register Indirect Mode,:163;
except that
before the operation the address register is decremented by
the size of the operand. If the stack pointer is used the
decrement is always by at least 2.

EA = -(An)

L:Continued:322;
. . .
}
T:MC68000 - Addressing modes Continued
Address Register Indirect with Displacement : This addressing mode is
identical to the;
L:Address Register Indirect Mode,:163;
except that
a sign extended 16 bit displacement is added to the address
register to find the address to access.

EA = d16(An)

Address Register Indirect with Index : This addressing mode is identical
to that above, except that an additional register may be added
on to the effective address before accessing memory. The
displacement is now only an 8 bit sign extended value.

EA = d8(An,Ri)

Absolute short : This addressing mode implies the use of an absolute word
sized value as the address to access.

EA = XXXX.W

L:Continued:323;
. . .
}
T:MC68000 - Addressing modes Continued
Absolute long : This addressing mode is identical to;
L:that above:322;
except that
the absolute value is longword sized.

EA = XXXXXX.L

Program Counter with Displacement : This addressing mode is similar to the
;
L:Address Register Indirect with Displacement:322;
mode. However in this
case the Program Counter is used instead of an Address Register.

EA = d16(PC)

Program Counter with Index : This addressing mode is similar to the
;
L:Address Register Indirect with Index:322;
mode. However in this case
the Program Counter is used instead of an Address Register.

EA = d8(PC,Ri)

Immediate value : This addressing mode implies that the value to use is
included in the instruction.

EA = #XXXXXXXX
}
T:MC68000 - Instructions
I have divided the 68000 instruction set in to logical categories.

L:Arithmetic:336;
: ABCD  ADDADDA  ADDI  ADDQ  ADDX  DIVS  DIVU  MULS  MULU
NBCD  NEGNEGX  SBCD  SUBSUBA  SUBI  SUBQ  SUBX

L:Logical:362;
: ANDANDI  ANDI_CCR  ANDI_SR  EOREORIEORI_CCR
EORI_SR  NOTORORIORI_CCR  ORI_SR

L:Shift and Rotations:363;
: ASLASRLSLLSRROLROR  ROXL  ROXR

L:Branches & Jumps:364;
: BccBRABSRDBcc  JMPJSR  RTERTR  RTS

L:Bit Operations:365;
: BCHG  BCLR  BSETBTST

L:Checking & Testing:366;
 : CHKCMPCMPACMPI  CMPM  TAS  TST

L:Loading & Moving:367;
: CLREXGLEAMOVE  MOVE_CCRMOVE>SR
$MOVE<SRMOVE_USPMOVEAMOVEM
$MOVEPMOVEQ  PEASccSWAP

L:Others:368;
: EXT ILLEGAL LINK NOP RESET STOP TRAP TRAPV UNLK
}
T:MC68000 - Arithmetic Instructions
The instructions below are used to perform simple
integer arithmetic on the MC68000 processor.

;
L:ABCD:377;
: Add Decimal with Extend
;
L:ADD:378;
 : Add Binary
;
L:ADDA:379;
: Add Address
;
L:ADDI:380;
: Add Immediate
;
L:ADDQ:381;
: Add Quick
;
L:ADDX:382;
: Add Extended
;
L:DIVS:383;
: Signed Divide
;
L:DIVU:384;
: Unsigned Divide
;
L:MULS:385;
: Signed Multiply
;
L:MULU:386;
: Unsigned Multiply
;
L:NBCD:387;
: Negate Decimal with Extend
;
L:NEG:388;
 : Negate
;
L:NEGX:389;
: Negate with Extend
;
L:SBCD:390;
: Subtract Decimal with Extend
;
L:SUB:391;
 : Subtract Binary
;
L:SUBA:392;
: Subtract Address
;
L:SUBI:393;
: Subtract Immediate
;
L:SUBQ:394;
: Subtract Quick
;
L:SUBX:395;
: Subtract with Extend
}
T:MC68000 - ABCD
This instruction adds the source and destination operands in BCD format
with the extend bit. The result in placed in the destination location.

Syntax : ABCD Dy,Dx
ABCD -(Ay),-(Ax)

Size: Byte

Condition codes :
N Undefined
Z Cleared if the result is non-zero, otherwise unchanged
V Undefined
C Set if a decimal carry was generated, otherwise cleared
X As for C
}
T:MC68000 - ADD
This instruction adds the source and destination operands and places
the result in the destination location.

Syntax : ADD <ea>,Dn<ea> can be any;
L:addressing mode:163
ADD Dn,<ea>

Size: Byte, word or longword

Condition codes :
N Set if result is negative, otherwise cleared
Z Set if result is zero, otherwise cleared
V Set if overflow is generated, otherwise cleared
C Set if a carry is generated, otherwise cleared
X As for C
}
T:MC68000 - ADDA
This instruction adds the source operand to the destination address
register and stores the result in the address register. Regardless
of the size specification of this instruction, the whole of the
destination address register is used.

Syntax : ADDA <ea>,An<ea> can be any;
L:addressing mode:163

Size: Word or longword

Condition codes : Not affected
}
T:MC68000 - ADDI
This instruction adds the supplied immediate value to the destination
operand and places the result in the destination location.

Syntax : ADDI #<data>,<ea><ea> Can be any;
L:addressing mode:163;
except
1;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Byte, word or longword

Condition codes : See;
L:ADD:378
}
T:MC68000 - ADDQ
This instruction adds the supplied immediate value, (between 1 and 8),
to the destination operand and places the result in the destination
location.

Syntax : ADDQ #<data>,<ea><ea> Can be any;
L:addressing mode:163;
except
1;
L:d16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Byte, word or longword, (NB:;
L:An addressing:163;
is word
4or longword only).

Condition codes : See;
L:ADD:378
}
T:MC68000 - ADDX
This instruction adds the source and destination operands with the
extend bit and places the result in the destination location.

Syntax : ADDX Dx,Dy
ADDX -(Ax),-(Ay)

Size: Byte, word or longword

Condition codes :
N Set if the result is negative, otherwise cleared
Z Cleared if the result is non-zero, otherwise unchanged
V Set if overflow is generated, otherwise unchanged
C Set if carry is generated, otherwise cleared
X As for C
}
T:MC68000 - DIVS
This instruction divides the longword destination operand by the word
sized data register using signed arithmetic. The quotient is then placed
in the lower word of the data register and the remainder in the upper
word of the data register.

Syntax : DIVS <ea>,Dn<ea> is any;
L:addressing mode:163;
except;
L:An:163

Size: Word

Condition codes :
N Set if the quotient is negative, otherwise cleared,
Undefined on overflow.
Z Set if the quotient is zero, otherwise cleared,
Undefined on overflow
V Set if division overflow is detected, otherwise cleared
C Always cleared
X Not affected

NOTE: Division by zero causes an;
L:exception:472;
to occur. Overflow may be
detected and set before completion. If overflow is detected the condition
is flagged but the operands are unaffected. Overflow occurs if the
quotient is bigger than a 16-bit signed integer.
}
T:MC68000 - DIVU
This instruction divides the longword destination operand by the word
sized data register using unsigned arithmetic. The quotient is then placed
in the lower word of the data register and the remainder in the upper
word of the data register.

Syntax : DIVU <ea>,Dn<ea> is any;
L:addressing mode:163;
except;
L:An:163

Size: Word

Condition codes :
N Set if the most significant bit of the quotient is set,
otherwise cleared. Undefined on overflow.
Z Set if the quotient is zero, otherwise cleared,
Undefined on overflow
V Set if division overflow is detected, otherwise cleared
C Always cleared
X Not affected

NOTE: See;
L:DIVS:383
}
T:MC68000 - MULS
This instruction multiplies the lower words of the source and data register
operands using signed arithmetic and places the longword result in the
data register.

Syntax : MULS <ea>,Dn<ea> is any;
L:addressing mode:163;
except;
L:An:163

Size: Word

Condition codes :
N Set if the result is negative, otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Always cleared
X Not affected
}
T:MC68000 - MULU
This instruction multiplies the lower words of the source and data register
operands using unsigned arithmetic and places the longword result in the
data register.

Syntax : MULU <ea>,Dn<ea> is any;
L:addressing mode:163;
except;
L:An:163

Size: Word

Condition codes :
N Set if the most significant bit of the result is set,
otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Always cleared
X Not affected
}
T:MC68000 - NBCD
This instruction subtracts the destination owperand and the extend bit
from zero and places the result in the destination location. This produces
the tens complement if the extend bit is clear and the nines complement
if the extend bit is set.

Syntax : NBCD <ea><ea> can be any;
L:addressing mode:163;
except
+;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte

Condition codes :
N Undefined
Z Cleared if the result is non-zero, otherwise unchanged
V Undefined
C Set if a decimal borrow was generated, otherwise cleared
X As for C
}
T:MC68000 - NEG
This instruction subtracts the destination operand from zero and places the
result in the destination location.

Syntax : NEG <ea><ea> can be any;
L:addressing mode:163;
except
*;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N Set if the result is negative, otherwise cleared
Z Set if the result is zero, otherwise cleared
V Set if overflow generated, otherwise cleared
C Cleared if the result is zero, otherwise set
X As for C
}
T:MC68000 - NEGX
This instruction subtracts the destination operand and the extend bit from
zero and places the result in the destination location.

Syntax : NEGX <ea><ea> can be any;
L:addressing mode:163;
except
+;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N Set if the result is negative, otherwise cleared
Z Cleared if the result is non-zero, otherwise unchanged
V Set if overflow is generated, otherwise cleared
C Set if borrow is generated, otherwise cleared
X As for C
}
T:MC68000 - SBCD
This instruction subtracts the source operand and the extend bit from
the destination operand. The result in placed in the destination location.

Syntax : SBCD Dy,Dx
SBCD -(Ay),-(Ax)

Size: Byte

Condition codes :
N Undefined
Z Cleared if the result is non-zero, otherwise unchanged
V Undefined
C Set if a decimal borrow was generated, otherwise cleared
X As for C
}
T:MC68000 - SUB
This instruction subtracts the source operand from the destination
operand and places the result in the destination location.

Syntax : SUB <ea>,Dn<ea> can be any;
L:addressing mode:163
SUB Dn,<ea>

Size: Byte, word or longword

Condition codes :
N Set if result is negative, otherwise cleared
Z Set if result is zero, otherwise cleared
V Set if overflow is generated, otherwise cleared
C Set if a borrow is generated, otherwise cleared
X As for C
}
T:MC68000 - SUBA
This instruction subtracts the source operand from the destination address
register and stores the result in the address register. Word sized source
operands are sign extended before the subtraction takes place.

Syntax : SUBA <ea>,An<ea> can be any;
L:addressing mode:163

Size: Word or longword

Condition codes : Not affected
}
T:MC68000 - SUBI
This instruction subtracts the supplied immediate value from the
destination operand and places the result in the destination location.

Syntax : SUBI #<data>,<ea><ea> can be any;
L:addressing mode:163;
except
3;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte, word or longword

Condition codes : See;
L:SUB:391
}
T:MC68000 - SUBQ
This instruction subtracts the supplied immediate value, (between 1
and 8), from the destination operand and places the result in the
destination location.

Syntax : SUBQ #<data>,<ea><ea> can be any;
L:addressing mode:163;
except
3;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte, word or longword, (NB: An addressing is word
4or longword only).

Condition codes : See;
L:SUB:391
}
T:MC68000 - SUBX
This instruction subtracts the source operand and the extend bit from
the destination operand and places the result in the destination location.

Syntax : SUBX Dx,Dy
SUBX -(Ax),-(Ay)

Size: Byte, word or longword

Condition codes :
N Set if the result is negative, otherwise cleared
Z Cleared if the result is non-zero, otherwise unchanged
V Set if overflow is generated, otherwise unchanged
C Set if borrow is generated, otherwise cleared
X As for C
}
T:MC68000 - Logical Instructions
The instructions below are used to perform
bitwise logical operations between effective
addresses, including the condition code and
status registers.

;
L:AND:396;
: AND Logical
;
L:ANDI:397;
: AND Immediate
;
L:ANDI_CCR:398;
: AND Immediate to Condition Codes
;
L:ANDI_SR:399;
 : AND Immediate to Status Register, (Privileged)
;
L:EOR:400;
: Exclusive OR Logical
;
L:EORI:401;
: Exclusive OR Immediate
;
L:EORI_CCR:402;
: Exclusive OR Immediate to Condition Codes
;
L:EORI_SR:403;
 : Exclusive OR Immediate to Status Register, (Privileged)
;
L:NOT:404;
: Logical Complement
;
L:OR:405;
: Inclusive OR Logical
;
L:ORI:406;
: Inclusive OR Immediate
;
L:ORI_CCR:407;
 : Inclusive OR immediate to Condition Codes
;
L:ORI_SR:408;
  : Inclusive OR immediate to Status Register, (Privileged)
}
T:MC68000 - AND
This instruction logically AND's the source and destination operands and
places the result in the destination location. That is, any bit that is
set in both source and destination is set in the result, otherwise it is
cleared.

Syntax : AND <ea>,Dn<ea> can be any;
L:addressing mode:163;
except;
L:An:163
AND Dn,<ea>

Size: Byte, word or longword

Condition codes :
N Set if the most significant bit of the result is set,
otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Always cleared
X Not affected
}
T:MC68000 - ANDI
This instruction logically AND's the supplied immediate value with the
destination operand and places the result in the destination location.

Syntax : ANDI #<data>,<ea><ea> can be any;
L:addressing mode:163;
except
/;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte, word or longword

Condition codes : See;
L:AND:396
}
T:MC68000 - ANDI_CCR
This instruction logically AND's the supplied immediate value with the
condition codes and places the result in the low byte of the status
register.

Syntax : ANDI #xxx,CCR

Size: Byte

Condition codes :
N Cleared if bit 3 of the immediate operand is zero, otherwise unchanged
Z"2"("
V"1"("
C"0"("
X"4"("
}
T:MC68000 - ANDI_SR
This instruction logically AND's the supplied immediate value with the
status register and places the result in the status register.

THIS IS A PRIVILEGED INSTRUCTION

Syntax : ANDI #xxx,SR

Size: Byte

Condition codes : See ANDI_CCR
}
T:MC68000 - EOR
This instruction logically EOR's the source and destination operands and
places the result in the destination location. That is, if a bit is set
in either the source or the destination, but not both, it is set in the
result, otherwise it is cleared.

Syntax : EOR Dn,<ea><ea> can be any;
L:addressing mode:163;
except
/;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N Set if the most significant bit of the result is set,
otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Always cleared
X Not affected
}
T:MC68000 - EORI
This instruction logically EOR's the supplied immediate value with the
destination operand and places the result in the destination location.

Syntax : EORI #<data>,<ea><ea> can be any;
L:addressing mode:163;
except
/;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte, word or longword

Condition codes : See;
L:EOR:400
}
T:MC68000 - EORI_CCR
This instruction logically EOR's the supplied immediate value with the
condition codes and places the result in the low byte of the status
register.

Syntax : EORI #xxx,CCR

Size: Byte

Condition codes :
N Changed if bit 3 of the immediate operand is one, otherwise unchanged
Z"2"("
V"1"("
C"0"("
X"4"("
}
T:MC68000 - EORI_SR
This instruction logically EOR's the supplied immediate value with the
status register and places the result in the status register.

THIS IS A PRIVILEGED INSTRUCTION

Syntax : EORI #xxx,SR

Size: Byte

Condition codes : See EORI_CCR
}
T:MC68000 - NOT
This instruction calculates the logical complement of the destination
operand and places the result in the destination location.

Syntax : NOT <ea><ea> can be any;
L:addressing mode:163;
except
/;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N Set if the result is negative, otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Always cleared
X Not affected
}
T:MC68000 - OR
This instruction logically OR's the source and destination operands and
places the result in the destination location. That is, if a bit is set
in either the source or the destination or both, it is set in the result,
otherwise it is cleared.

Syntax : OR <ea>,Dn<ea> can be any;
L:addressing mode:163;
except;
L:An:163
OR Dn,<ea>

Size: Byte, word or longword

Condition codes :
N Set if the most significant bit of the result is set,
otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Always cleared
X Not affected
}
T:MC68000 - ORI
This instruction logically OR's the supplied immediate value with the
destination operand and places the result in the destination location.

Syntax : ORI #<data>,<ea><ea> can be any addressing mode except
0An, d16(PC), d8(PC,Ri), Imm

Size: Byte, word or longword

Condition codes : See;
L:OR:405
}
T:MC68000 - ORI_CCR
This instruction logically OR's the supplied immediate value with the
condition codes and places the result in the low byte of the status
register.

Syntax : ORI #xxx,CCR

Size: Byte

Condition codes :
N Set if bit 3 of the immediate operand is one, otherwise unchanged
Z"2"("
V"1"("
C"0"("
X"4"("
}
T:MC68000 - ORI_SR
This instruction logically OR's the supplied immediate value with the
status register and places the result in the status register.

THIS IS A PRIVILEGED INSTRUCTION

Syntax : ORI #xxx,SR

Size: Byte

Condition codes : See ORI_CCR
}
T:MC68000 - Shifts And Rotations
The instructions below are used to perform
shifts and rotations on effective addresses.

;
L:ASL/ASR:409;
  : Arithmetic Shift
;
L:LSL/LSR:410;
  : Logical Shift
;
L:ROL/ROR:411;
  : Rotate without Extend
;
L:ROXL/ROXR:412;
: Rotate with Extend
}
T:MC68000 - ASL/ASR
These instructions arithmetically shift the bits of the destination
operand in the specified direction. The carry bit receives the last
bit shifted out of the operand. The shift count may be specified either
as an immediate value or in a data register, or as an implied 1.

Syntax : ASd Dx,Dy
ASd #<data>,Dy<ea> may be any;
L:addressing mode:163;
except
ASd <ea> ;
L:Dn,:163;
L:An,:163;
L:D16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Byte, word or longword

Shifts to the left result in zeroes being placed in the least significant
bit of the operand. Shifts to the right result in the sign bit being
copied back to its original position.

Condition codes :
  N Set if the most significant bit of the result is set, otherwise cleared
  Z Set if the result is zero, otherwise cleared
  V Set if the msbit is ever changed during the operation otherwise cleared
  C Set as mentioned above. Cleared for a shift count of zero
  X As for C, except unaffected for a shift count of zero
}
T:MC68000 - LSL/LSR
These instructions act in an identical manner to the arithmetic shifts,
ASL and ASR except that the logical shift to the right has zeroes placed
in the most significant bit rather than propogating the sign bit.

Syntax : LSd Dx,Dy
LSd #<data>,Dy<ea> can be any;
L:addressing mode:163;
except
LSd <ea>;
L:Dn,:163;
L:An,:163;
L:D16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N Set if the result is negative, otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Set according to last bit shifted out. Cleared on 0 shift count
X As for C, except unaffected on 0 shift count
}
T:MC68000 - ROL/ROR
These instructions rotate the bits in the destination operand in the
specified direction. The extend bit is not included. Any bit rotated out
of the operand is placed in the carry flag and replaced at the other end
of the operand. The rotate count is specified either as an immediate
value, in a data register or as an implied 1.

Syntax : ROd Dx,Dy
ROd #<data>,Dy<ea> may be any;
L:addressing mode:163;
except
ROd <ea> ;
L:Dn,:163;
L:An,:163;
L:D16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N Set if the msbit of the result is set, otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Set according to the last bit shifted out,
cleared on a shift count of zero
X Not affected
}
T:MC68000 - ROXL/ROXR
These instructions perform operand rotations including the extend bit. A
bit shifted out of the operand is placed in the extend flag, the bit used
to replace the lost one at the other end is taken from the extend flag. The
rotate count is specified either as an immediate value, in a data register
or as an implied 1.

Syntax : ROXd DX,Dy
ROXd #<data>,Dy<ea> may be any;
L:addressing mode:163;
except
ROXd <ea>;
L:Dn,:163;
L:An,:163;
L:D16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N Set if the msbit of the result is set, otherwise cleared
Z Set if the result is zero, otherwise cleared
V Always cleared
C Set according to the last bit shifted out,
Set to the value of the extend flag on a shift count of zero
X Set according to the last bit shifted out.
Unaffected on a shift count of zero
}
T:MC68000 - Branches And Jumps
The instructions below are used to perform
jumps, call subroutines and return from
subroutines.

;
L:Bcc:413;
 : Branch Conditionally
;
L:BRA:414;
 : Branch Always
;
L:BSR:415;
 : Branch to Subroutine
;
L:DBcc:416;
: Test Condition, Decrement and Branch
;
L:JMP:417;
 : Jump
;
L:JSR:418;
 : Jump to Subroutine
;
L:RTE:419;
 : Return from Exception
;
L:RTR:420;
 : Return and Restore Condition Codes
;
L:RTS:421;
 : Return from Subroutine
}
T:MC68000 - Bcc
This instruction will perform a branch to (PC)+displacement if the
condition code specified by 'cc' is met. The displacement is a two's
complement integer  which counts the relative distance in bytes. The
value in PC is the current instruction location plus two.

Syntax : Bcc <label>

Size: Byte or word

Condition codes : Not affected

The possible condition code suffixes to this instruction are

CC  Carry clear"LS  Low or same
CS  Carry set$LT  Less than
EQ  Equal(MI  Minus
GE  Greater or equalNE  Not equal
GT  Greater than!PL  Plus
HI  High)VC  Overflow clear
LE  Less or equal VS  Overflow set
}
T:MC68000 - BRA
This instruction causes program execution to continue at the specified
label.

Syntax : BRA <label>

Size: Byte or word

Condition codes : Not affected
}
T:MC68000 - BSR
This instruction causes the address of the next instruction to be placed
on the stack and program execution to continue at the specified label.

Syntax : BSR <label>

Size: Byte or word

Condition codes : Not affected

See;
L:RTS,:421;
(Return from subroutine), for the instruction that gets you back
from the subroutine.
}
T:MC68000 - DBcc
This instruction is a looping primitive. Firstly the condition is tested
and if it is met no further action is taken. If it is not met then the
specified data register is decremented. The value of this register is then
tested. If it is equal to -1 then no further action is taken, otherwise
a branch to the specified label is done.

Syntax : DBcc Dn,<label>

Size: Word

Condition codes : Not affected

Possible condition code suffixes for this instruction are

CC  Carry clear  GE  Greater or Equal  LS  Low or same  PL  Plus
CS  Carry setGT  Greater thanLT  Less thanTTrue
EQ  EqualHI  HighMI  MinusVC  Overflow clear
FFalseLE  Less or equalNE  Not equalVS  Overflow set
}
T:MC68000 - JMP
This instruction causes execution to be continued at the specified
address.

Syntax : JMP <ea><ea> may be;
L:(An),:163;
L:d16(An),:322;
L:d8(An,Ri),:322;
L:Abs.W:322
);
L:Abs.L,:323;
L:d16(PC):323;
or;
L:d8(PC,Ri):323

Condition codes : Not affected
}
T:MC68000 - JSR
This instruction is similar to BSR, however the address to jump to has
to be specified in a similar way to JMP.

Syntax : JSR <ea><ea> is as for;
L:JMP:417

Condition codes : Not affected

See;
L:RTS,:421;
(Return from subroutine), for the instruction that gets you back
from the subroutine.
}
T:MC68000 - RTE
This instruction causes the status register and program counter to be
pulled from the stack. The previous status register and program counter
are lost. All bits in the status register are affected.

THIS IS A PRIVILEGED INSTRUCTION

Syntax : RTE

Condition codes : Set according to the word pulled off the stack.
}
T:MC68000 - RTR
This instruction causes the condition codes and program counter to be
pulled from the stack. The previous condition codes and program counter
are lost. The least significant byte of the status register is affected.

Syntax : RTR

Condition codes : Set according to the word pulled off the stack.
}
T:MC68000 - RTS
This instruction causes the program counter to be pulled from the stack.
The previous program counter is lost.

Syntax : RTS

Condition codes : Not affected

See;
L:BSR:415;
and;
L:JSR:418;
for the situations where this instruction is used.
}
T:MC68000 - Bit Operations
The instructions below are used to manipulate
single bits within an effective address.

;
L:BCHG:422;
: Test a Bit and Change
;
L:BCLR:423;
: Test a Bit and Clear
;
L:BSET:424;
: Test a Bit and Set
;
L:BTST:425;
: Test a Bit
}
T:MC68000 - BCHG
This instruction tests a specified bit in the destination operand and
then complements it. If a data register is the destination then it is
a longword operation and bits 0 to 31 can be tested, in any other case
it is a byte operation and only bits 0 to 7 can be used.

Syntax : BCHG Dn,<ea><ea> can be any;
L:addressing mode:163;
except
BCHG #<data>,<ea>;
L:An,:163;
L:d16(PC),:323;
L:d8(PC):323;
or;
L:Imm:323

Size: Byte or longword

Condition codes : Not affected, except
Z  Set if the bit tested was zero, otherwise cleared
}
T:MC68000 - BCLR
This instruction tests a specified bit in the destination operand and
then clears it. If a data register is the destination then it is a
longword operation and bits 0 to 31 can be tested, in any other case
it is a byte operation and only bits 0 to 7 can be used.

Syntax : BCLR Dn,<ea><ea> can be any;
L:addressing mode:163;
except
BCLR #<data>,<ea>;
L:An,:163;
L:d16(PC),:323;
L:d8(PC):323;
or;
L:Imm:323

Size: Byte or longword

Condition codes : Not affected, except
Z  Set if the bit tested was zero, otherwise cleared
}
T:MC68000 - BSET
This instruction tests a specified bit in the destination operand and
then sets it. If a data register is the destination then it is a longword
operation and bits 0 to 31 can be tested, in any other case it is a byte
operation and only bits 0 to 7 can be used.

Syntax : BSET Dn,<ea><ea> can be any;
L:addressing mode:163;
except
BSET #<data>,<ea>;
L:An,:163;
L:d16(PC),:323;
L:d8(PC):323;
or;
L:Imm:323


Size: Byte or longword

Condition codes : Not affected, except
Z  Set if the bit tested was zero, otherwise cleared
}
T:MC68000 - BTST
This instruction tests a specified bit in the destination operand. If a
data register is the destination then it is a longword operation and bits
0 to 31 can be tested, in any other case it is a byte operation and only
bits 0 to 7 can be used.

Syntax : BTST Dn,<ea><ea> can be any;
L:addressing mode:163;
except
BTST #<data>,<ea>;
L:An:163;
or;
L:Imm:323

Size: Byte or longword

Condition codes : Not affected, except
Z  Set if the bit tested was zero, otherwise cleared
}
T:MC68000 - Checking And Testing
The instructions below are used to test values
and compare them.

;
L:CHK:426;
 : Check Register Against Bounds
;
L:CMP:427;
 : Compare
;
L:CMPA:428;
: Compare Address
;
L:CMPI:429;
: Compare Immediate
;
L:CMPM:430;
: Compare Memory
;
L:TAS:431;
 : Test and Set an Operand
;
L:TST:432;
 : Test an Operand
}
T:MC68000 - CHK
This instruction compares the low order word of the destination operand
data register against zero and an upper bound. If the contents of the
register is less than zero or greater than the two's complement upper
bound then an;
L:exception:472;
is caused.

Syntax : CHK <ea>,Dn<ea> can be any;
L:addressing mode:163;
except;
L:An:163

Size: Word

Condition codes :
N  Set if Dn<0, cleared if Dn>(<ea>), otherwise undefined
Z  Undefined
V  Undefined
C  Undefined
X  Not affected
}
T:MC68000 - CMP
This instruction subtracts the source operand from the destination operand
and sets the condition codes accordingly. The destination location is not
affected.

Syntax : CMP <ea>,Dn<ea> can be any;
L:addressing mode:163

Size: Byte, word or longword

Condition codes :
N  Set if the result is negative, otherwise cleared
Z  Set if the result is zero, otherwise cleared
V  Set if overflow is generated, otherwise cleared
C  Set if borrow is generated, otherwise cleared
X  Not affected

Note :;
L:CMPA:428;
is used where the destination is an address register
;
L:CMPI:429;
is used where the source is an immediate value
;
L:CMPM:430;
is used for memory to memory compares
}
T:MC68000 - CMPA
This instruction subtracts the source operand from the destination address
register and sets the condition codes accordingly. The address register is
not affected. Word length source operands are sign extended before the
operation is performed.

Syntax : CMPA <ea>,An<ea> can be any;
L:addressing mode:163

Size: Word or longword

Condition codes : See;
L:CMP:427
}
T:MC68000 - CMPI
This instruction subtracts the source immediate value from the destination
operand and sets the condition codes accordingly. The destination location
is not affected.

Syntax : CMPI #<data>,<ea><ea> can be any;
L:addressing mode:163;
except
4;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
or;
L:Imm:323

Size: Byte, word or longword

Condition codes : See;
L:CMP:427
}
T:MC68000 - CMPM
This instruction subtracts the source operand
from the destination operand and sets the
condition codes accordingly. The destination
location is not affected.

Syntax : CMPM (Ax)+,(Ay)+

Size: Byte, word or longword

Condition codes : See;
L:CMP:427
}
T:MC68000 - TAS
This instruction tests the specified byte and sets the condition codes
accordingly. The high order bit of the specified byte is then set. This
instruction is indivisible and cannot be subdivided. This allows for the
synchronisation of several processors.

Syntax : TAS <ea><ea> can be any;
L:addressing mode:163;
except
1;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
or;
L:Imm:323

Size: Byte

Condition codes :
N  Set if the msbit of the operand was set, otherwise cleared
Z  Set if the operand was zero, otherwise cleared
V  Always cleared
C  Always cleared
X  Not affected
}
T:MC68000 - TST
This instruction compares the operand with zero and set the
condition codes accordingly.

Syntax : TST <ea><ea> can be any;
L:addressing mode:163;
except
4;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri),:323;
or;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N  Set if the operand is negative, otherwise cleared
Z  Set if the operand is zero, otherwise cleared
V  Always cleared
C  Always cleared
X  Not affected
}
T:MC68000 - Loading And Moving
The instructions below are used to load values
in to effective addresses and move values between
effective addresses.

;
L:CLR:433;
: Clear an Operand
;
L:EXG:434;
: Exchange Registers
;
L:LEA:435;
: Load Effective Address
;
L:MOVE:436;
: Move Data from Source to Destination
;
L:MOVE_CCR:437;
: Move to Condition Codes
;
L:MOVE>SR:438;
 : Move to Status Register, (privileged)
;
L:MOVE<SR:439;
 : Move from Status Register
;
L:MOVE_USP:440;
: Move User Stack Pointer, (privileged)
;
L:MOVEA:441;
: Move Address
;
L:MOVEM:442;
: Movem Multiple Registers
;
L:MOVEP:443;
: Move Peripheral Data
;
L:MOVEQ:444;
: Move Quick
;
L:PEA:445;
: Push Effective Address
;
L:Scc:446;
: Set According to Condition
;
L:SWAP:447;
: Swap Register Halves
}
T:MC68000 - CLR
This instruction sets all bits in the destination operand to 0.

Syntax : CLR <ea><ea> may be any;
L:addressing mode:163;
except
*;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Byte, word or longword

Condition codes :
N  Always cleared
Z  Always set
V  Always cleared
C  Always cleared
X  Not affected
}
T:MC68000 - EXG
This instruction exchanges the complete contents of two registers.

Syntax : EXG Rx,Ry

Size: Longword

Condition codes : Not affected
}
T:MC68000 - LEA
This instruction loads the effective address source operand in to the
destination address register.

Syntax : LEA <ea>,An<ea> may be any;
L:addressing mode:163;
except
.;
L:Dn,:163;
L:An,:163;
L:(An)+,:321;
L:-(An):321;
or;
L:Imm:323

Size: Longword

Condition codes : Not affected
}
T:MC68000 - MOVE
This instruction moves the content of the source operand to the destination
operand. The contents are examined in transit and the condition codes set
accordingly.

Syntax : MOVE <ea1>,<ea2><ea2> may be any;
L:addressing mode:163;
except
1;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

,<ea1> may be any;
L:addressing mode:163

Size: Byte, word or longword

Condition codes :
N  Set if the result is negative, otherwise cleared
Z  Set if the result is zero, otherwise cleared
V  Always cleared
C  Always cleared
X  Not affected

Note:;
L:MOVEA:441;
is used when the destination is an address register
;
L:MOVEQ:442;
can be used in certain cases with data registers
}
T:MC68000 - MOVE_CCR
This instruction moves the low order byte of the source operand in to the
condition code register.

Syntax : MOVE <ea>,CCR<ea> can be any;
L:addressing mode:163;
except;
L:An:163

Size: Word

Condition codes :
N  Set the same as bit 3 of the source operand
Z  Set the same as bit 2 of the source operand
V  Set the same as bit 1 of the source operand
C  Set the same as bit 0 of the source operand
X  Set the same as bit 4 of the source operand
}
T:MC68000 - MOVE>SR
This instruction moves the source operand in to the status register.

THIS IS A PRIVILEGED INSTRUCTION

Syntax : MOVE <ea>,SR<ea> can be any;
L:addressing mode:163;
except;
L:An:163

Size: Word

Condition codes : Set according to the source operand, see;
L:MOVE_CCR:437
}
T:MC68000 - MOVE<SR
This instruction moves the status register to the source operand.

This instruction is not privileged on the 68000 but is privileged on
the more recent 010, 020, 030 and 040 processors. Watch out TT!

Syntax : MOVE SR,<ea><ea> can be any;
L:addressing mode:163;
except
0;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Word

Condition codes : Not affected
}
T:MC68000 - MOVE_USP
This instruction is used to move the contents of the user stack pointer
to or from the specified address register.

THIS IS A PRIVILEGED INSTRUCTION

Syntax : MOVE USP,An
MOVE An,USP

Size: Longword

Condition codes : Not affected
}
T:MC68000 - MOVEA
This instruction moves the source operand in to the specified destination
address register. Word sized sources are sign extended before the move.

Syntax : MOVE <ea>,An<ea> may be any;
L:addressing mode:163

Size: Word or longword

Condition codes : Not affected
}
T:MC68000 - MOVEM
This instruction moves a list of registers to or from a specified effective
address. If the word sized form is used then the registers are sign
extended and written as longwords.

Syntax : MOVEM <register list>,<ea1><ea1> may be;
L:(An),:163;
L:-(An),:321;
L:d16(An):322
>;
L:d8(An,Ri),:322;
L:Abs.W:322;
or;
L:Abs.L:323;

MOVEM <ea2>,<register list>  <ea2> may not be;
L:Dn,:163;
L:An,:163;
L:-(An):321;
or;
L:Imm:323

Size: Word or longword

Condition codes : Not affected
}
T:MC68000 - MOVEP
This instruction transfers data between a data register
and alternate bytes of memory starting at the location
specified and incrementing by two.

Syntax : MOVEP Dx,d16(Ay)
MOVEP d16(Ay),Dx

Size: Word or longword

Condition codes : Not affected
}
T:MC68000 - MOVEQ
This instruction sign extends the supplied 8-bit immediate value in to
the destination data register.

Syntax : MOVEQ #<data>,Dx

Size: Longword

Condition codes :
N  Set if the result is negative, otherwise cleared
Z  Set if the result is zero, otherwise cleared
V  Always cleared
C  Always cleared
X  Not affected
}
T:MC68000 - PEA
This instruction pushes the effective address on to the stack

Syntax : PEA <ea><ea> may be as it is for;
L:LEA:435

Size: Longword

Condition codes : Not affected
}
T:MC68000 - Scc
This instruction tests the condition and if it is true the specified
destination is set to all 1's, otherwise it is cleared to all 0's.

Syntax : Scc <ea><ea> may be any;
L:addressing mode:163;
except
-;
L:An,:163;
L:d16(PC),:323;
L:d8(PC,Ri):323;
or;
L:Imm:323

Size: Byte

Condition codes : Not affected

The condition suffixes to this instruction are the same as those for
L:DBcc.:416
}
T:MC68000 - SWAP
This instruction swaps the low order and high order words
in the specified data register.

Syntax : SWAP Dn

Size: Word

Condition codes :
N  Set if the msbit of the result is set, otherwise cleared
Z  Set if the 32 bit result is zero, otherwise cleared
V  Always cleared
C  Always cleared
X  Not affected
}
T:MC68000 - Other Instructions
The instructions below would not, easily,
fit in to any of the other categories.

;
L:EXT:448;
: Sign Extend
;
L:ILLEGAL:449;
: Illegal Instruction
;
L:LINK:450;
: Link and Allocate
;
L:NOP:451;
: No Operation
;
L:RESET:452;
  : Reset External Devices, (privileged)
;
L:STOP:453;
: Load Status Register and Stop, (privileged)
;
L:TRAP:454;
: Trap
;
L:TRAPV:455;
  : Trap on Overflow
;
L:UNLK:456;
: Unlink
}
T:MC68000 - EXT
This instruction extends the sign bit of either a byte or a word
to cover the rest of the word or longword. That is, in a bytes
operation bit 7 is copied to bits 8-15, and in a word operation bit
15 is copied to bits 16-31.

Syntax : EXT Dn

Size: Word or longword

Condition codes :
N  Set if the rsult is negative, otherwise cleared
Z  Set if the result is zero, otherwise cleared
V  Always cleared
C  Always cleared
X  Not affected
}
T:MC68000 - ILLEGAL
This instruction causes an illegal instruction;
L:exception.:472

Syntax : ILLEGAL

Condition codes : Not affected
}
T:MC68000 - LINK
This instruction places the contents of the specified address register
on the stack . The new stack pointer is then loaded in to the address
register and the stack pointer has the specified displacement added on.
With negative displacements this can be used to reserve stack space.

Syntax : LINK An,#<displacement>

Condition codes : Not affected

This instuction is typically used with;
L:UNLK.:456
}
T:MC68000 - NOP
This instruction does nothing.

Syntax : NOP

Condition codes : Not affected
}
T:MC68000 - RESET
This instruction causes the reset line to all external peripherals to
be asserted. The processor is not affected in any way.

THIS IS A PRIVILEGED INSTRUCTION

Syntax : RESET

Condition codes : Not affected
}
T:MC68000 - STOP
This instruction places the supplied immediate value in to the status
register and stops the processor until a trace, interrupt or reset
L:exception:472;
occurs.

Syntax : STOP #xxx

Condition codes : Set according to the immediate operand
}
T:MC68000 - TRAP
This instruction initiates;
L:exception:472;
processing using the vector of the
specified exception routine.

Syntax : TRAP #xxx

Condition codes : Not affected
}
T:MC68000 - TRAPV
This instruction initiates execution of the oevrflow;
L:exception:472;
if the
overflow flag is set. There is no effect otherwise.

Syntax : TRAPV

Condition codes : Not affected
}
T:MC68000 - UNLK
This instruction loads the stack pointer from the specified address
register. The address register is then loaded with the value from the
top of the stack. This instruction is the inverse of;
L:LINK.:450

Syntax : UNLK An

Condition codes : Not affected
}
T:MC68000 - Timings
This sections details the times that each of the instructions of the 68000
takes to execute. The times are specified in clock cycles. On a standard
8Mhz Atari ST there are 8,000,000 clock cycles in a second.

L:<ea> Calculation Times:457

L:Move Byte and Word,:458;
(MOVE)
L:Move Longword,:459;
(MOVE)
L:Standard Instructions,:460;
(ADD,AND,CMP,DIV,EOR,MUL,OR,SUB)
L:Immediate Instructions,:461;
(ADDI,ADDQ,ANDI,CMPI,EORI,MOVEQ,ORI,SUBI,SUBQ)
L:Single Operand Ins.,:462;
(CLR,NBCD,NEG,NEGX,NOT,Scc,TAS,TST)
L:Shifts and Rotates,:463;
(ASL,ASR,LSL,LSR,ROL,ROR,ROXL,ROXR)
L:Bit Manipulation,:464;
(BCHG,BCLR,BSET,BTST)
L:Conditional Instructions,:465;
  (Bcc,BRA,BSR,DBcc,CHK,TRAP,TRAPV)
L:Some others,:466;
(JMP,JSR,LEA,PEA,MOVEM)
L:Multi-precision Ins.,:467;
(ADDX,CMPM,SUBX,ABCD,SBCD)
L:Miscellaneous Instructions,:468;
(ANDI_CCR,ANDI_SR,EORI_CCR,EORI_SR,EXG,EXT,LINK
+MOVE_CCR,MOVE>SR,MOVE<SR,MOVE_USP,NOP,ORI_CCR,
+ORI_SR,RESET,RTE,RTR,RTS,STOP,SWAP,UNLK,MOVEP)

}
T:MC68000 - Effective Address Calculation Times
Addressing Mode&Byte,Word  Longword

L:Dn:163;
Data Register Direct)00
L:An:163;
Address Register Direct&00

L:(An):163;
Address Register Indirect$48

L:(An)+:321;
Address Register Indirect with Postincrement48
L:-(An):321;
Address Register Indirect with Predecrement610

L:d16(An):322;
Address Register Indirect with Displacement812
L:d8(An,Ri):322;
 Address Register Indirect with Index1014

L:xxx.W:322;
Absolute Short/812
L:xxx.L:323;
Absolute Long01216

L:d16(PC):323;
Program Counter with Displacement812
L:d8(PC,Ri):323;
 Program Counter with Index#1014

L:#xxx:323;
Immediate448
}
T:MC68000 - Move Byte and Word
Source)Destination
Dn  An  (An)  (An)+  -(An)  d16(An)  d8(An,Ri)  xxx.W  xxx.L

Dn4488812141216
An4488812141216

(An)8812121216181620

(An)+8812121216181620
-(An)10  1014141418201822

d16(An)12  1216161620222024
d8(An,Ri)  14  1418181822242226

xxx.W12  1216161620222024
xxx.L16  1620202024262428

d16(PC)12  1216161620222024
d8(PC,Ri)  14  1418181822242226

#xxx8812121216181620
}
T:MC68000 - Move Longword
Source)Destination
Dn  An  (An)  (An)+  -(An)  d16(An)  d8(An,Ri)  xxx.W  xxx.L

Dn4412121416181620
An4412121416181620

(An)12  1220202024262428

(An)+12  1220202024262428
-(An)14  1422222226282630

d16(An)16  1624242428302832
d8(An,Ri)  18  1826262630323034

xxx.W16  1624242428302832
xxx.L20  2028282832343236

d16(PC)16  1624242428302832
d8(PC,Ri)  18  1826262630323034

#xxx12  1220202024262428
}
T:MC68000 - Timings - Standard Instructions
op <ea>,Anop <ea>,Dnop Dn,<M>

L:ADD:378;
B & W8+4+8+
L6+**6+**12+
L:AND:396;
B & W-4+8+
L-6+**12+
L:CMP:427;
B & W6+4+-
L6+6+-
L:DIVS:383;
-158+*-
L:DIVU:384;
-140+*-
L:EOR:400;
B & W-48+
L-812+
L:MULS:385;
-70+*-
L:MULU:386;
-70+*-
L:OR:405;
B & W-4+8+
L-6+**12+
L:SUB:391;
B & W8+4+8+
L6+**6+**12+

+ Add;
L:<ea> calculation time:457
* Maximum value  ** Total of 8 if Register Direct
}
T:MC68000 - Timings - Immediate Instructions
op #,Dnop #,Anop #,<M>

L:ADDI:380;
  B & W8-12+
L16-20+
L:ADDQ:381;
  B & W488+
L8812+
L:ANDI:397;
  B & W8-12+
L16-20+
L:CMPI:429;
  B & W888+
L141412+
L:EORI:401;
  B & W8-12+
L16-20+
L:MOVEQ:444;
4--
L:ORI:406;
B & W8-12+
L16-20+
L:SUBI:393;
  B & W8-12+
L16-20+
L:SUBQ:394;
  B & W488+
L8812+

+ Add;
L:<ea> calculation time:457
}
T:MC68000 - Timings - Single Operand
RegisterMemory

L:CLR:433;
  B & W48+
L612+
L:NBCD:387;
68+
L:NEG:388;
  B & W48+
L612+
L:NEGX:389;
 B & W48+
L612+
L:NOT:404;
  B & W48+
L612+
L:Scc:446;
  False48+
True68+
L:TAS:431;
410+
L:TST:432;
  B & W44+
L44+

+ Add;
L:<ea> calculation time:457
}
T:MC68000 - Timings - Shifts and Rotates
"RegisterMemory

L:ASL,ASR:409;
B & W6+2n8+
L8+2n-

L:LSL,LSR:410;
B & W6+2n8+
L8+2n-

L:ROL,ROR:411;
B & W6+2n8+
L8+2n-

L:ROXL,ROXR:412;
B & W6+2n8+
L8+2n-

+ Add;
L:<ea> calculation time:457
n Is the shift count
}
T:MC68000 - Timings - Bit Manipulation
DynamicStatic
RegisterMemoryRegister  Memory

L:BCHG:422;
  B-8+-12+
L8*-12*-

L:BCLR:423;
  B-8+-12+
L10*-14*-

L:BSET:424;
  B-8+-12+
L8*-12*-

L:BTST:425;
  B-4+-8+
L6-10-

+ Add;
L:<ea> calculation time:457
* Maximum value
}
T:MC68000 - Timings - Conditional Instructions
Trap/Branch TakenTrap/Branch not Taken
L:Bcc:413;
B10#8
W10"12

L:BRA:414;
B10#-
W10#-

L:BSR:415;
B18#-
W18#-

L:DBcc:416;
  cc True-"12
cc False  10"14

L:CHK:426;
40+*!8+

L:TRAP:454;
34#-

L:TRAPV:455;
34#4

+ Add;
L:<ea> calculation time:457
* Maximum value
}
T:MC68000 - Timings - Some others
(An)(An)+ -(An) d16(An) d8(An,Ri) xxx.W  xxx.L d16(PC) d8(PC,Ri)

L:JMP:417;
8--101410121014

L:JSR:418;
16--182218201822

L:LEA:435;
4--812812812

L:PEA:445;
12--162016201620

L:MOVEM:442;
 W  12+4n  12+4n  -16+4n18+4n16+4n20+4n  16+4n  18+4n
M > R  L  12+8n  12+8n  -16+8n18+8n16+8n20+8n  16+8n  18+8n

L:MOVEM:442;
 W  8+5n-8+5n12+5n14+5n12+5n16+5n--
R > M  L  8+10n-8+10n  12+10n  14+10n  12+10n  16+10n  --

n Is the number of registers to move
}
T:MC68000 - Timings - Multi-precision Instr's
#op Dn,Dnop <M>,<M>

L:ADDX:382;
B & W418
L830

L:CMPM:430;
B & W-12
L-20

L:SUBX:395;
B & W418
L830

L:ABCD:377;
"618

L:SBCD:390;
"618
}
T:MC68000 - Timings - Miscellaneous Instructions
RegisterMemory!RegisterMemory
L:ANDI_CCR:398;
20-;
L:NOP:451;
4-
L:ANDI_SR:399;
20-;
L:ORI_CCR:407;
20-
L:EORI_CCR:402;
20-;
L:ORI_SR:408;
20-
L:EOR_SR:403;
20-;
L:RESET:452;
132-
L:EXG:434;
6-;
L:RTE:419;
20-
L:EXT:448;
4-;
L:RTR:420;
20-
L:LINK:450;
18-;
L:RTS:421;
16-
L:MOVE_CCR:437;
18-;
L:STOP:453;
4-
L:MOVE>SR:438;
1212+;
L:SWAP:447;
4-
L:MOVE<SR:439;
1212+;
L:UNLK:456;
12-
L:MOVE_USP:440;
4-

Register > MemoryMemory > Register
L:MOVEP:443;
W16!16
L24!24

+ Add;
L:<ea> calculation time:457
}
T:The MC68901
This section covers the MC68901
Multi-Function Processor.

 ;
L:Timers:166
 ;
L:Interrupt control:167
 ;
L:Configuration registers:168
}
T:MC68901 - Timers
The M68901 has 4 timers labelled A to D. In the Atari ST
these timers have the following functions.

Timer A : DMA sound counter, (STE only)
Timer B : Hblank counter
Timer C : 200Hz system timer
Timer D : RS-232 baud rate generator

The operation of these timers can be controlled using the
Xbios function Xbtimer.
}
T:MC68901 - Interrupt Control
These are the MFP hardware bound interrupts

PriorityFunction
15 highMonochrome monitor detectGPI(7)
14RS-232 ring indicator!GPI(6)
13Timer A
12RS-232 receive buffer full
11RS-232 receive error
10RS-232 transmit buffer empty
 9RS-232 transmit error
 8Horizontal blanking counter, Timer B
 7Disk drive controller!GPI(5)
 6Keyboard and MIDI%GPI(4)
 5System clock, Timer C
 4RS-232 baud rate generator, Timer D
 3GPU operation done$GPI(3)
 2RS-232 Clear to send"GPI(2)
 1RS-232 Data carrier detectGPI(1)
 0Parallel port busy$GPI(0)
}
T:MC68901 - Configuration Registers
The MC68901 configuration registers are located at address $FFFA01

Offset  Function!Offset  Function
 01General Purpose I/O19Timer A control
 03Active Edge1BTimer B control
 05Data Direction1DTimer C&D control
 07Interrupt Enable A1FTimer A data
 09Interrupt Enable B21Timer B data
 0BInterrupt Pending A23Timer C data
 0DInterrupt Pending B25Timer D data
 0FInterrupt In-service A27Sync character
 11Interrupt In-service B29Usart control
 13Interrupt Mask A2BReceiver status
 15Interrupt Mask B2DTransmitter status
 17Vector base address2FUsart data
}
T:The MC6850
This section covers the MC6850
Asynchronous Communications Interface
Adaptor, (ACIA). This device controls
the keyboard and MIDI ports.

;
L:Receive status register:170
;
L:Transmit status register:171
}
T:MC6850 - Receive status register
Bit  Function
 7Interrupt request
 6Parity error
 5Rx overrun, (character lost)
 4Framing error
 3CTS
 2DCD
 1Tx data register empty
 0Rx data register full
}
T:MC6850 - Transmit status register
BitFunction
 70  Rx interrupt disable
1  Rx interrupt enable
6&50 0  RTS low Tx interrupt disable
0 1  RTS low Tx interrupt enabled
1 0  RTS high Tx interrupt disable
1 1  RTS low Tx a break on to data output. Tx interrupt disable
4,3&2  0 0 0  7 bits even 2 stop bits
0 0 1  7odd  2
0 1 0  7even 1
0 1 1  7odd  1
1 0 0  8 bits 2 stop bits
1 0 1  81
1 1 0  8 bits even 1 stop bit
1 1 1  8odd  1
1&00 0  normal  }
0 1  div 16  } Divide select bits
1 0  div 64  }
1 1  Master reset
}
T:The YM2149
This section covers the YM2149, Yamaha Programmable Sound Generator.

Register Function"Bits used
 0,1Channel A fine/coarse tune0-7/0-3
 2,3Channel B fine/coarse tune0-7/0-3
 4,5Channel C fine/coarse tune0-7/0-3
 6Noise period!0-4
 7Mixer control - I/O enable
 8Channel A amplitude} 0-3, 4 indicates
 9Channel B amplitude} fixed or variable
 10Channel C amplitude} amplitude.
 11Envelope period fine0-7
 12Envelope period coarse0-7
 13Envelope shape0=Hold 1=Alternate 2=Ramp 3=Cycle
 14I/O port A (output only)
 15I/O port B (centronics)

The PSG can be controlled by the following;
L:Xbios:6;
system calls,
L:Dosound,:36;
L:Giaccess,:45;
L:Ongibit:57;
and;
L:Offgibit.:58;
}
T:The System Variables
This section covers all of the documented system variables.

Address: Size: Mnemonic:  Function:

$400Letv_timer  Timer handoff
$404Letv_critic Critical error handoff
$408Letv_termProcess terminate handoff vector
$40C5*Letv_xtraSpace for reserved logical vectors

$420LmemvalidCold start ok
$424BmemcntlrMemory controller low nibble

$426Lresvalid#$31415926 to jump through resvector
$42ALresvector  System reset bailout vector

$42ELphystopPhysical top of RAM
$432L_membotAvailable memory bottom
$436L_memtopAvailable memory top
$43ALmemval2

L:Click to continue:172;
. . .
}
T:The System Variables Continued
Address: Size: Mnemonic:  Function:
$43EWflockFloppy FIFO lock variable
$440Wseekrate0=6ms 1=12ms 2=2ms 3=3ms
$442W_timr_msSystem timer calibration
$444W_fverify0 = no write verify
$446W_bootdevSystem boot device number

$448Wpalmode0 = NTSC 60Hz, else PAL 50Hz
$44ABdefshtmdDefault video res. if monitor changed
$44CBsshiftmdShadow shiftmd hardware register
(0 = 320x200x4
(1 = 640x200x2
(2 = 620x400x1
$44EL_v_bas_ad  Screen memory base pointer
$452WvblsemVirtical blank mutual exclusion semaphore
(1 = vblank enabled
$454WnvblsNumber of longwords vblqueue points to
$456L_vblqueue  Vblank handler pointer to pointers
$45ALcolorptrPointer to 16 word palette table

L:Click to continue:469;
. . .
}
T:The System Variables Continued
Address: Size: Mnemonic:Function:
$45ELscreenptPointer to screen base next vblank
$462L_vbclockVertical blank interrupt count
$466L_frclockCount vblank interrupts not vblsem'd

$46ALhdv_initHard disk initialisze vector else zero
$46ELswv_vec'Monitor changed' vector to follow
$472Lhdv_bpbHard disk vector to return bpb else zero
$476Lhdv_rwHard disk read/write routine vector else zero
$47ALhdv_bootHard disk boot routine vector else zero
$47ELhdv_mediach Disk media change routine vector else zero

$482BcontermAttribute bits for console
)0  bell on
)1  keyrepeat
)2  key click
)3 ;
L:Kbshift:32;
bits
$485BReserved

L:Click to continue:470;
. . .
}
T:The System Variables Continued
Address: Size: Mnemonic:Function:
$486Ltrp14retSaved trap 14 return address
$48ALcriticretSaved return address for etv_critic

$48ELthemdGemdos memory descriptors

$4A2Lsavptr;
L:Bios:5;
register save area pointer
$4A6W_nflopsNumber of floppies attached
$4A8Lcon_stateState of conout() parser
$4ACWsave_rowSave row for x/y addressing
$4AELsav_contxt  Pointer to saved processor context

$4B2L_buflGemdos two buffer-list pointers

$4BAL_hz_200Raw 200Hz timer tick
$4BELthe_envDefault environment string
$4C2L_drvbitsBitmap of existing drives, see;
L:Drvmap:31
$4C6L_dskbufpPointer to common disk buffer

L:Click to continue:471;
. . .
}
T:The System Variables Continued
Address: Size: Mnemonic:Function:
$4CAL_autopathPointer to autoexec path (or null)
$4CE8xL_vbl_listInitial vblqueue
$4EEW_prt_cntInitially -1, Alt+Help increments
$4F0W_prtabtPrinter abort flag
$4F2L_sysbaseBase of OS pointer
$4F6L_shell_pGlobal shell info pointer
$4FALend_osPointer to end of OS memory usage
$4FELexec_osPointer to shell address to execute on startup
$5A0L_p_cookies  Pointer to the cookie jar

_sysbase + $20 _rootPointer to the base of the OS Pool
_sysbase + $24;
L:kbshift:32;
Pointer to byte holding shift key status
_sysbase + $28 _runPointer to longword process ID
}
T:The Configuration Registers
MEMORY

$FF8004 r/w Bits 0-3Bank 0Bank 1
%0  128K128K
%1  128K512K
%2  128K2M
%3  Reserved
%4  512K128K
%5  512K512K
%6  512K2M
%7  Reserved
%8  2M128K
%9  2M512K
$10  2M2M
$11  Reserved
$12+ Reserved

L:Click to continue:473;
. . .
}
T:The Configuration Registers Continued
DISPLAY

$FF8201 r/wVideo base high
$FF8203 r/wVideo base low
$FF8205  rVideo address counter high
$FF8207  rVideo address counter mid
$FF8209  rVideo address counter low
$FF820A r/wBit 0  External(1)/Internal(0) sync
Bit 1  50Hz(1)/60Hz(0) field rate
$FF8240 r/w  Bits 0-2  Blue component of palette colour 0
Bits 4-6  Green component of palette colour 0
Bits 8-10  Red component of palette colour 0
$FF8242 r/wPalette colour 1
$FF8244 r/wPalette colour 2
.....
.....
$FF825E r/wPalette colour 15
$ff8260 r/w  Bits 0-1  Shift mode
%0  320x200, 4 plane1  640x200, 2 plane
%2  640x400, 1 plane3  Reserved

L:Click to continue:474;
. . .
}
T:The Configuration Registers Continued
RESERVED
$FF8400Reserved

DMA/DISK
$FF8600Reserved
$FF8602Reserved
$FF8604 r/wDisk controller data access
$FF8606  rDMA status,
Bit 0  Error
Bit 1  Sector count zero
Bit 2  Data request inactive
$FF8606  wDMA mode control
Bit 0  A0 - WD1772 register
Bit 1  A1 - WD1772 register
Bit 2  HDC(1)/FDC(0) register select
Bit 3  Sector count register select
Bit 4  0 reserved
Bit 5  Disable(1)/Enable(0) DMA
Bit 6  FFDC(1)/HDC(0)
L:Continue:475;
Bit 7  Write(1)/Read(0)
}
T:The Configuration Registers Continued
$FF8609 r/wDMA base and counter high
$FF860B r/wDMA base and counter mid
$FF860D r/wDMA base and counter low

SOUND
$FF8800  rPSG read data, I/O port B, parallel interface data
wPSG register select
$FF8802  wPSG write data
Bit 0  Floppy side 0(1)/side 1(0)
Bit 1  Floppy drive 0 select
Bit 2  Floppy drive 1 select
Bit 3  RS-232 RTS
Bit 4  RS-232 DTR
Bit 5  Centronics strobe
Bit 6  General purpose output
Bit 7  Reserved

L:Click to continue:476;
. . .
}
T:The Configuration Registers Continued
MC68901

$FFFA01MFP G.P. I/O
Bit 0  Parallel port status
Bit 4  WD1772 active
Bit 5  Interrupt
Bit 7  Mono monitor
$FFFA03}
.!} MC68901 configuration registers
$FFFA2F}

MC6850

$FFFC00Keyboard ACIA control
$FFFC02Keyboard data
$FFFC04MIDI ACIA control
$FFFC06MIDI data
}
T:VT52 Terminal Escape Codes
EscapeFunctionComments
  ACursor upUp one line, no effect at top
  BCursor downDown one line no effect at bottom
  CCursor right  Right one position, no effect at edge
  DCursor leftLeft one position, no effect at edge

  EClear screen  Clear screen and home cursor to 0,0
  HHome cursorHome cursor to 0,0
  ICursor upUp one line, scroll if at top

  JErase eopErase to end of page, from and including cursor
  KErase eolErase to end of line, froum cursor
  LInsert lineInsert blank line above current, cursor at start
  MDelete lineDelete cursor line and move those below up

Y,r,cCursor r,cPosition cursor at position r-32,c-32

 b,fForegroundForeground colour is 4 lsb of f
 c,bBackgroundBackground colour is 4 lsb of b

L:Click to continue:477;
. . .
}
T:VT52 Terminal Escape Codes Continued
EscapeFunctionComments
  dErase sopErase to start of page including cursor

  eShow cursorShow the cursor
  fHide cursorHide the cursor
  jSave cursorSave the cursor position
  kRestore cursor Restore the cursor position

  lErase lineErase line and move cursor to start
  oErase solErase to start of line including cursor

  pReverse video Enter everse video mode
  qNormal video  Exit reverse video mode

  vWrap onWrap at end of a line and scroll if necessary
  wWrap offOverwrite character at end of line
}
T:ASCII Codes
Dec. Hex. Char.%Dec. Hex. Char.
 000NUL  Null!1812DC2
 101SOH'1913DC3
 202STX'2014DC4
 303ETX'2115NAK  No acknowledge
 404EOT  End of transmission2216SYN
 505ENQ  Enquire2317ETB
 606ACK  Acknowledge2418CAN  Cancel
 707BEL  Bell!2519EM
 808BSBackspace261ASUB
 909HTHorizontal tab271BESC  Escape
 100ALFLine feed281CFS
 110BVTVertical tab291DGS
 120CFFForm feed301ERS
 130DCRCarriage return311FUS
 140ESO(3220Space
 150FSI(3321!
 1610DLE'3422"
 1711DC1'3523#

L:Click to continue:478;
. . .
}
T:ASCII Codes Continued
Dec. Hex. Char.Dec. Hex. Char.Dec. Hex. Char.
 3624$543667248H
 3725%553777349I
 3826&56388744AJ
 3927'57399754BK
 4028(583A:764CL
 4129)593B;774DM
 422A*603C<784EN
 432B+613D=794FO
 442C,623E>8050P
 452D-633F?8151Q
 462E.6440@8252R
 472F/6541A8353S
 483006642B8454T
 493116743C8555U
 503226844D8656V
 513336945E8757W
 523447046F8858X
 533557147G8959Y

L:Click to continue:479;
. . .
}
T:ASCII Codes Continued
Dec. Hex. Char.Dec. Hex. Char.Dec. Hex. Char.
 905AZ104  68h118  76v
 915B[105  69i119  77w
 925C\106  6Aj120  78x
 935D]107  6Bk121  79y
 945E^108  6Cl122  7Az
 955F_109  6Dm123  7B{
 9660`110  6En124  7C|
 9761a111  6Fo125  7D}
 9862b112  70p126  7E~
 9963c113  71q127  7FDEL
 100  64d114  72r
 101  65e115  73s
 102  66f116  74t
 103  67g117  75u
}
T:GEM VDI Standard Keyboard Codes
Hi  Lo  Char.Hi  Lo  Char.Hi  Lo  Char.Hi  Lo  Char.
03  00  Ctrl-213  12  Ctrl-R06  25  %08  37  7
1E  01  Ctrl-A1F  13  Ctrl-S08  26  &09  38  8
30  02  Ctrl-B14  14  Ctrl-T28  27  '0A  39  9
2E  03  Ctrl-C16  15  Ctrl-U0A  28  (27  3A  :
20  04  Ctrl-D2F  16  Ctrl-V0B  29  )27  3B  ; 
12  05  Ctrl-E11  17  Ctrl-W09  2A  *33  3C  <
21  06  Ctrl-F2D  18  Ctrl-X0D  2B  +0D  3D  =
22  07  Ctrl-G15  19  Ctrl-Y33  2C  ,34  3E  >
23  08  Ctrl-H2C  1A  Ctrl-Z0C  2D  -35  3F  ?
17  09  Ctrl-I1A  1B  Ctrl-[34  2E  .03  40  @
24  0A  Ctrl-J2B  1C  Ctrl-\35  2F  /1E  41  A
25  0B  Ctrl-K1B  1D  Ctrl-]0B  30  030  42  B
26  0C  Ctrl-L07  1E  Ctrl--02  31  12E  43  C
32  0D  Ctrl-M39  20  SPACE03  32  220  44  D
31  0E  Ctrl-N02  21  !04  33  312  45  E
18  0F  Ctrl-O28  22  "05  34  421  46  F
19  10  Ctrl-P2B  23  #06  35  522  47  G
10  11  Ctrl-Q05  24  $07  36  623  48  H

L:Click to continue:480;
. . .
}
T:GEM VDI Standard Keyboard Codes Continued
Hi  Lo  Char.Hi  Lo  Char.Hi  Lo  Char.Hi  Lo  Char.
17  49  I1A  5B  [32  6D  m53  7F  Delete
24  4A  J2B  5C  \31  6E  n81  00  Alt-0
25  4B  K1B  5D  ]18  6F  o78  00  Alt-1
26  4C  L07  5E  ^19  70  p79  00  Alt-2
32  4D  M0C  5F  _10  71  q7A  00  Alt-3
31  4E  N29  60  `13  72  r7B  00  Alt-4
18  4F  O1E  61  a1F  73  s7C  00  Alt-5
19  50  P30  62  b14  74  t7D  00  Alt-6
10  51  Q2E  63  c16  75  u7E  00  Alt-7
13  52  R20  64  d2F  76  v7F  00  Alt-8
1F  53  S12  65  e11  77  w80  00  Alt-9
14  54  T21  66  f2D  78  x1E  00  Alt-A
16  55  U22  67  g15  79  y30  00  Alt-B
2F  56  V23  68  h2C  7A  z2E  00  Alt-C
11  57  W17  69  i1A  7B  {20  00  Alt-D
2D  58  X24  6A  j60  7C  |12  00  Alt-E
15  59  Y25  6B  k1B  7D  }21  00  Alt-F
2C  5A  Z26  6C  l29  7E  ~22  00  Alt-G

L:Click to continue:481;
. . .
}
T:GEM VDI Standard Keyboard Codes Continued
Hi  Lo  Char.Hi  Lo  Char.Hi  Lo  Char.
23  00  Alt-H2C  00  Alt-Z5B  00  Shft F8
17  00  Alt-I3B  00  F15C  00  Shft F9
24  00  Alt-J3C  00  F25D  00  Shft F10
25  00  Alt-K3D  00  F373  00  Ctrl-Cursor Left
26  00  Alt-L3E  00  F474  00  Ctrl-Cursor Right
32  00  Alt-M3F  00  F54B  34  Shft-Cursor Left
31  00  Alt-N40  00  F64D  36  Shft-Cursor Right
18  00  Alt-O41  00  F748  38  Shft-Cursor Up
19  00  Alt-P42  00  F850  32  Shft-Cursor Down
10  00  Alt-Q43  00  F94B  00  Cursor Left
13  00  Alt-R44  00  F104D  00  Cursor Right
1F  00  Alt-S54  00  Shft F148  00  Cursor Up
14  00  Alt-T55  00  Shft F250  00  Cursor Down
16  00  Alt-U56  00  Shft F377  00  Ctrl-Home
2F  00  Alt-V57  00  Shft F447  37  Shft-Home
11  00  Alt-W58  00  Shft F547  00  Home
2D  00  Alt-X59  00  Shft F652  30  Shft-Insert
15  00  Alt-Y5A  00  Shft F752  00  Insert

L:Click to continue:482;
. . .
}
T:GEM VDI Standard Keyboard Codes Continued
Hi  Lo  Char.
53  2E  Shft-Delete
01  1B  Escape
0E  08  Backspace
82  00  Alt--
83  00  Alt-=
1C  0D  Return
1C  0A  Shft-Return
0F  09  Tab
}
T:System Error Codes
Number  Meaning&Number  Meaning
0Ok, (no error)-32Invalid function number
-1Fundamental error-33File not found
-2Drive not ready-34Path not found
-3Unknown command-35Too many files open
-4CRC error$-36Access denied
-5Bad request"-37Invalid handle
-6Seek error#-39Insufficient memory
-7Unknown media -40Invalid memory block address
-8Sector not found-46Invalid drive
-9No paper%-49No more files
-10Write fault"-64Range error
-11Read fault#-65Internal error
-12General error -66Invalid program load format
-13Write protect -67Setblock failed due to
-14Media change)growth restrictions.
-15Unknown device
-16Bad sectors on format
-17Insert other disk
}
T:Exception Vectors
$000Reset initial SSP$060Spurious interrupt
$004Reset initial PC address$064Interrupt Level 1
$008Bus error%$068Interrupt Level 2
$00CAddress error#...
$010ILLEGAL instruction$07CInterrupt Level 7
$014Divide by zero $080Trap #0
$018CHK instruction$084Trap #1
$01CTRAPV instruction$088Trap #2
$020Privilege violation...
$024Trace mode$$0B0Trap #12
$028Line-A($0B4Trap #13
$02CLine-F($0B8Trap #14
$030Unassigned$$0BCTrap #15
$03468020 specific $0C0Unassigned
$03868020 specific"...
$03CUninitialized interrupt$0FCUnassigned
$040Unassigned
  ...
$05CUnassigned#;
L:Click to continue:483;
. . .

}
T:Exception Vectors Continued
MFP hardware bound interrupt vectors
$100Parallel poer interrupt 0
$104RS-232 carrier detect interrupt 1
$108RS-232 Clear to send interrupt 2
$10CGraphics blit done interrupt 3
$110RS-232 baud rate generator (Timer D)
$114200Hz system clock (Timer C)
$118Keyboard/MIDI (6850) interrupt 4
$11CPolled fdc/hdc interrupt 5
$120Horizontal blank counter i(Timer B)
$124RS-232 transmit error interrupt
$128RS-232 transmit buffer empty interrupt
$12CRS-232 receive error interrupt
$130RS-232 receive buffer full interrupt
$134Timer A
$138RS-232 ring indicator interrupt 6
$13CPolled monochrome monitor detect interrupt 7
$140-$1FF  Unassigned
$200-$37C  Reserved for OEMs
}
T:Bibliography
The ST 68k Reference was only ever intended as a 'memory jogger', or
quick reference guide. Thus I would suggest that if you cannot find
the information you require you should turn to one of these books that
have helped me enjoy my ST that much more.

Lattice C version 5 : If you program in C and you are not using this
system then you should be saving furiously. It may seem a little
expensive but the manuals are the greatest source of information on
TOS that I have ever seen. The compiler is pretty good too.

The Concise Atari ST 68000 Programmer's Reference Guide : This is not
a book for the beginner or faint-hearted. You have to treat it as a
source of reference, you will not be able to learn from it.
ISBN 1 851181 017 X - Katherine Peel - Glentop Publishers Ltd

Signetics S68000 User's Guide : Everything you ever wanted to know
about the MC68000 processor. Comes free with DevpacST.

L:Continue:324
}
T:Bibliography Continued
Programming The 68000 : Everything you ever wanted to know about the
MC68000 processor, and how to program it!!.
ISBN 0 89588 133 0 - Steve Williams - Sybex

Atari ST Internals : Again, not a book you will keep by your bed, but
a valuable source of, usually correct, information. Often gives a little
more detail on some subjects that TCAST68000PRG skips briefly over.
ISBN 0 916439 46 1 - Gerits, Englisch + Bruckmann - Data Becker + Abacus

Atari ST GEM Programmer's Reference : Gives bare detail on most AES and
VDI function calls. There is some interesting comment between the chapters
but it will not get you far.
ISBN 0 916439 52 6 - Szczepanowski + Gunther - Data Becker + Abacus

The manuals for Computer Concepts' Fast BASIC, HiSoft BASIC and DevpacST
have also been very helpful in the past.
